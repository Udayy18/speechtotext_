{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { createNoDashGuid, Deferred, Events } from \"../common/Exports\";\nimport { ConnectingToServiceEvent, ListeningStartedEvent, RecognitionStartedEvent, RecognitionTriggeredEvent } from \"./RecognitionEvents\";\nimport { ServiceTelemetryListener } from \"./ServiceTelemetryListener.Internal\";\nexport class RequestSession {\n  constructor(audioSourceId) {\n    this.privIsDisposed = false;\n    this.privDetachables = new Array();\n    this.privIsAudioNodeDetached = false;\n    this.privIsRecognizing = false;\n    this.privIsSpeechEnded = false;\n    this.privTurnStartAudioOffset = 0;\n    this.privLastRecoOffset = 0;\n    this.privHypothesisReceived = false;\n    this.privBytesSent = 0;\n    this.privRecogNumber = 0;\n    this.privInTurn = false;\n    this.privConnectionAttempts = 0;\n    this.privAudioSourceId = audioSourceId;\n    this.privRequestId = createNoDashGuid();\n    this.privAudioNodeId = createNoDashGuid();\n    this.privTurnDeferral = new Deferred(); // We're not in a turn, so resolve.\n\n    this.privTurnDeferral.resolve();\n  }\n\n  get sessionId() {\n    return this.privSessionId;\n  }\n\n  get requestId() {\n    return this.privRequestId;\n  }\n\n  get audioNodeId() {\n    return this.privAudioNodeId;\n  }\n\n  get turnCompletionPromise() {\n    return this.privTurnDeferral.promise;\n  }\n\n  get isSpeechEnded() {\n    return this.privIsSpeechEnded;\n  }\n\n  get isRecognizing() {\n    return this.privIsRecognizing;\n  }\n\n  get currentTurnAudioOffset() {\n    return this.privTurnStartAudioOffset;\n  }\n\n  get recogNumber() {\n    return this.privRecogNumber;\n  }\n\n  get numConnectionAttempts() {\n    return this.privConnectionAttempts;\n  } // The number of bytes sent for the current connection.\n  // Counter is reset to 0 each time a connection is established.\n\n\n  get bytesSent() {\n    return this.privBytesSent;\n  }\n\n  listenForServiceTelemetry(eventSource) {\n    if (!!this.privServiceTelemetryListener) {\n      this.privDetachables.push(eventSource.attachListener(this.privServiceTelemetryListener));\n    }\n  }\n\n  startNewRecognition() {\n    this.privIsSpeechEnded = false;\n    this.privIsRecognizing = true;\n    this.privTurnStartAudioOffset = 0;\n    this.privLastRecoOffset = 0;\n    this.privRecogNumber++;\n    this.privServiceTelemetryListener = new ServiceTelemetryListener(this.privRequestId, this.privAudioSourceId, this.privAudioNodeId);\n    this.onEvent(new RecognitionTriggeredEvent(this.requestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));\n  }\n\n  onAudioSourceAttachCompleted(audioNode, isError) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privAudioNode = audioNode;\n      this.privIsAudioNodeDetached = false;\n\n      if (isError) {\n        yield this.onComplete();\n      } else {\n        this.onEvent(new ListeningStartedEvent(this.privRequestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));\n      }\n    });\n  }\n\n  onPreConnectionStart(authFetchEventId, connectionId) {\n    this.privAuthFetchEventId = authFetchEventId;\n    this.privSessionId = connectionId;\n    this.onEvent(new ConnectingToServiceEvent(this.privRequestId, this.privAuthFetchEventId, this.privSessionId));\n  }\n\n  onAuthCompleted(isError) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (isError) {\n        yield this.onComplete();\n      }\n    });\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  onConnectionEstablishCompleted(statusCode, reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (statusCode === 200) {\n        this.onEvent(new RecognitionStartedEvent(this.requestId, this.privAudioSourceId, this.privAudioNodeId, this.privAuthFetchEventId, this.privSessionId));\n\n        if (!!this.privAudioNode) {\n          this.privAudioNode.replay();\n        }\n\n        this.privTurnStartAudioOffset = this.privLastRecoOffset;\n        this.privBytesSent = 0;\n        return;\n      } else if (statusCode === 403) {\n        yield this.onComplete();\n      }\n    });\n  }\n\n  onServiceTurnEndResponse(continuousRecognition) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privTurnDeferral.resolve();\n\n      if (!continuousRecognition || this.isSpeechEnded) {\n        yield this.onComplete();\n        this.privInTurn = false;\n      } else {\n        // Start a new request set.\n        this.privTurnStartAudioOffset = this.privLastRecoOffset;\n        this.privAudioNode.replay();\n      }\n    });\n  }\n\n  onSpeechContext() {\n    this.privRequestId = createNoDashGuid();\n  }\n\n  onServiceTurnStartResponse() {\n    if (!!this.privTurnDeferral && !!this.privInTurn) {\n      // What? How are we starting a turn with another not done?\n      this.privTurnDeferral.reject(\"Another turn started before current completed.\"); // Avoid UnhandledPromiseRejection if privTurnDeferral is not being awaited\n      // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n      this.privTurnDeferral.promise.then().catch(() => {});\n    }\n\n    this.privInTurn = true;\n    this.privTurnDeferral = new Deferred();\n  }\n\n  onHypothesis(offset) {\n    if (!this.privHypothesisReceived) {\n      this.privHypothesisReceived = true;\n      this.privServiceTelemetryListener.hypothesisReceived(this.privAudioNode.findTimeAtOffset(offset));\n    }\n  }\n\n  onPhraseRecognized(offset) {\n    this.privServiceTelemetryListener.phraseReceived(this.privAudioNode.findTimeAtOffset(offset));\n    this.onServiceRecognized(offset);\n  }\n\n  onServiceRecognized(offset) {\n    this.privLastRecoOffset = offset;\n    this.privHypothesisReceived = false;\n    this.privAudioNode.shrinkBuffers(offset);\n    this.privConnectionAttempts = 0;\n  }\n\n  onAudioSent(bytesSent) {\n    this.privBytesSent += bytesSent;\n  }\n\n  onRetryConnection() {\n    this.privConnectionAttempts++;\n  }\n\n  dispose() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.privIsDisposed) {\n        // we should have completed by now. If we did not its an unknown error.\n        this.privIsDisposed = true;\n\n        for (const detachable of this.privDetachables) {\n          yield detachable.detach();\n        }\n\n        if (!!this.privServiceTelemetryListener) {\n          this.privServiceTelemetryListener.dispose();\n        }\n\n        this.privIsRecognizing = false;\n      }\n    });\n  }\n\n  getTelemetry() {\n    if (this.privServiceTelemetryListener.hasTelemetry) {\n      return this.privServiceTelemetryListener.getTelemetry();\n    } else {\n      return null;\n    }\n  }\n\n  onStopRecognizing() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.onComplete();\n    });\n  } // Should be called with the audioNode for this session has indicated that it is out of speech.\n\n\n  onSpeechEnded() {\n    this.privIsSpeechEnded = true;\n  }\n\n  onEvent(event) {\n    if (!!this.privServiceTelemetryListener) {\n      this.privServiceTelemetryListener.onEvent(event);\n    }\n\n    Events.instance.onEvent(event);\n  }\n\n  onComplete() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!!this.privIsRecognizing) {\n        this.privIsRecognizing = false;\n        yield this.detachAudioNode();\n      }\n    });\n  }\n\n  detachAudioNode() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.privIsAudioNodeDetached) {\n        this.privIsAudioNodeDetached = true;\n\n        if (this.privAudioNode) {\n          yield this.privAudioNode.detach();\n        }\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["src/common.speech/RequestSession.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { ReplayableAudioNode } from \"../common.browser/Exports\";\r\nimport {\r\n    createNoDashGuid,\r\n    Deferred,\r\n    Events,\r\n    IDetachable,\r\n    IEventSource,\r\n    PlatformEvent\r\n} from \"../common/Exports\";\r\nimport {\r\n    ConnectingToServiceEvent,\r\n    ListeningStartedEvent,\r\n    RecognitionStartedEvent,\r\n    RecognitionTriggeredEvent,\r\n    SpeechRecognitionEvent,\r\n} from \"./RecognitionEvents\";\r\nimport { ServiceTelemetryListener } from \"./ServiceTelemetryListener.Internal\";\r\n\r\nexport class RequestSession {\r\n    private privIsDisposed: boolean = false;\r\n    private privServiceTelemetryListener: ServiceTelemetryListener;\r\n    private privDetachables: IDetachable[] = new Array<IDetachable>();\r\n    private privRequestId: string;\r\n    private privAudioSourceId: string;\r\n    private privAudioNodeId: string;\r\n    private privAudioNode: ReplayableAudioNode;\r\n    private privAuthFetchEventId: string;\r\n    private privIsAudioNodeDetached: boolean = false;\r\n    private privIsRecognizing: boolean = false;\r\n    private privIsSpeechEnded: boolean = false;\r\n    private privTurnStartAudioOffset: number = 0;\r\n    private privLastRecoOffset: number = 0;\r\n    private privHypothesisReceived: boolean = false;\r\n    private privBytesSent: number = 0;\r\n    private privRecogNumber: number = 0;\r\n    private privSessionId: string;\r\n    private privTurnDeferral: Deferred<void>;\r\n    private privInTurn: boolean = false;\r\n    private privConnectionAttempts: number = 0;\r\n\r\n    public constructor(audioSourceId: string) {\r\n        this.privAudioSourceId = audioSourceId;\r\n        this.privRequestId = createNoDashGuid();\r\n        this.privAudioNodeId = createNoDashGuid();\r\n        this.privTurnDeferral = new Deferred<void>();\r\n\r\n        // We're not in a turn, so resolve.\r\n        this.privTurnDeferral.resolve();\r\n    }\r\n\r\n    public get sessionId(): string {\r\n        return this.privSessionId;\r\n    }\r\n\r\n    public get requestId(): string {\r\n        return this.privRequestId;\r\n    }\r\n\r\n    public get audioNodeId(): string {\r\n        return this.privAudioNodeId;\r\n    }\r\n\r\n    public get turnCompletionPromise(): Promise<void> {\r\n        return this.privTurnDeferral.promise;\r\n    }\r\n\r\n    public get isSpeechEnded(): boolean {\r\n        return this.privIsSpeechEnded;\r\n    }\r\n\r\n    public get isRecognizing(): boolean {\r\n        return this.privIsRecognizing;\r\n    }\r\n\r\n    public get currentTurnAudioOffset(): number {\r\n        return this.privTurnStartAudioOffset;\r\n    }\r\n\r\n    public get recogNumber(): number {\r\n        return this.privRecogNumber;\r\n    }\r\n\r\n    public get numConnectionAttempts(): number {\r\n        return this.privConnectionAttempts;\r\n    }\r\n\r\n    // The number of bytes sent for the current connection.\r\n    // Counter is reset to 0 each time a connection is established.\r\n    public get bytesSent(): number {\r\n        return this.privBytesSent;\r\n    }\r\n    public listenForServiceTelemetry(eventSource: IEventSource<PlatformEvent>): void {\r\n        if (!!this.privServiceTelemetryListener) {\r\n            this.privDetachables.push(eventSource.attachListener(this.privServiceTelemetryListener));\r\n        }\r\n    }\r\n\r\n    public startNewRecognition(): void {\r\n        this.privIsSpeechEnded = false;\r\n        this.privIsRecognizing = true;\r\n        this.privTurnStartAudioOffset = 0;\r\n        this.privLastRecoOffset = 0;\r\n        this.privRecogNumber++;\r\n        this.privServiceTelemetryListener = new ServiceTelemetryListener(this.privRequestId, this.privAudioSourceId, this.privAudioNodeId);\r\n        this.onEvent(new RecognitionTriggeredEvent(this.requestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));\r\n    }\r\n\r\n    public async onAudioSourceAttachCompleted(audioNode: ReplayableAudioNode, isError: boolean): Promise<void> {\r\n        this.privAudioNode = audioNode;\r\n        this.privIsAudioNodeDetached = false;\r\n\r\n        if (isError) {\r\n            await this.onComplete();\r\n        } else {\r\n            this.onEvent(new ListeningStartedEvent(this.privRequestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));\r\n        }\r\n    }\r\n\r\n    public onPreConnectionStart(authFetchEventId: string, connectionId: string): void {\r\n        this.privAuthFetchEventId = authFetchEventId;\r\n        this.privSessionId = connectionId;\r\n        this.onEvent(new ConnectingToServiceEvent(this.privRequestId, this.privAuthFetchEventId, this.privSessionId));\r\n    }\r\n\r\n    public async onAuthCompleted(isError: boolean): Promise<void> {\r\n        if (isError) {\r\n            await this.onComplete();\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public async onConnectionEstablishCompleted(statusCode: number, reason?: string): Promise<void> {\r\n        if (statusCode === 200) {\r\n            this.onEvent(new RecognitionStartedEvent(this.requestId, this.privAudioSourceId, this.privAudioNodeId, this.privAuthFetchEventId, this.privSessionId));\r\n            if (!!this.privAudioNode) {\r\n                this.privAudioNode.replay();\r\n            }\r\n            this.privTurnStartAudioOffset = this.privLastRecoOffset;\r\n            this.privBytesSent = 0;\r\n            return;\r\n        } else if (statusCode === 403) {\r\n            await this.onComplete();\r\n        }\r\n    }\r\n\r\n    public async onServiceTurnEndResponse(continuousRecognition: boolean): Promise<void> {\r\n        this.privTurnDeferral.resolve();\r\n\r\n        if (!continuousRecognition || this.isSpeechEnded) {\r\n            await this.onComplete();\r\n            this.privInTurn = false;\r\n        } else {\r\n            // Start a new request set.\r\n            this.privTurnStartAudioOffset = this.privLastRecoOffset;\r\n            this.privAudioNode.replay();\r\n        }\r\n    }\r\n\r\n    public onSpeechContext(): void {\r\n        this.privRequestId = createNoDashGuid();\r\n    }\r\n\r\n    public onServiceTurnStartResponse(): void {\r\n        if (!!this.privTurnDeferral && !!this.privInTurn) {\r\n            // What? How are we starting a turn with another not done?\r\n            this.privTurnDeferral.reject(\"Another turn started before current completed.\");\r\n            // Avoid UnhandledPromiseRejection if privTurnDeferral is not being awaited\r\n            // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n            this.privTurnDeferral.promise.then().catch((): void => { });\r\n        }\r\n        this.privInTurn = true;\r\n        this.privTurnDeferral = new Deferred<void>();\r\n    }\r\n\r\n    public onHypothesis(offset: number): void {\r\n        if (!this.privHypothesisReceived) {\r\n            this.privHypothesisReceived = true;\r\n            this.privServiceTelemetryListener.hypothesisReceived(this.privAudioNode.findTimeAtOffset(offset));\r\n        }\r\n    }\r\n\r\n    public onPhraseRecognized(offset: number): void {\r\n        this.privServiceTelemetryListener.phraseReceived(this.privAudioNode.findTimeAtOffset(offset));\r\n        this.onServiceRecognized(offset);\r\n    }\r\n\r\n    public onServiceRecognized(offset: number): void {\r\n        this.privLastRecoOffset = offset;\r\n        this.privHypothesisReceived = false;\r\n        this.privAudioNode.shrinkBuffers(offset);\r\n        this.privConnectionAttempts = 0;\r\n    }\r\n\r\n    public onAudioSent(bytesSent: number): void {\r\n        this.privBytesSent += bytesSent;\r\n    }\r\n\r\n    public onRetryConnection(): void {\r\n        this.privConnectionAttempts++;\r\n    }\r\n\r\n    public async dispose(): Promise<void> {\r\n        if (!this.privIsDisposed) {\r\n            // we should have completed by now. If we did not its an unknown error.\r\n            this.privIsDisposed = true;\r\n            for (const detachable of this.privDetachables) {\r\n                await detachable.detach();\r\n            }\r\n\r\n            if (!!this.privServiceTelemetryListener) {\r\n                this.privServiceTelemetryListener.dispose();\r\n            }\r\n            this.privIsRecognizing = false;\r\n        }\r\n    }\r\n\r\n    public getTelemetry(): string {\r\n        if (this.privServiceTelemetryListener.hasTelemetry) {\r\n            return this.privServiceTelemetryListener.getTelemetry();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public async onStopRecognizing(): Promise<void> {\r\n        await this.onComplete();\r\n    }\r\n\r\n    // Should be called with the audioNode for this session has indicated that it is out of speech.\r\n    public onSpeechEnded(): void {\r\n        this.privIsSpeechEnded = true;\r\n    }\r\n\r\n    protected onEvent(event: SpeechRecognitionEvent): void {\r\n        if (!!this.privServiceTelemetryListener) {\r\n            this.privServiceTelemetryListener.onEvent(event);\r\n        }\r\n        Events.instance.onEvent(event);\r\n    }\r\n\r\n    private async onComplete(): Promise<void> {\r\n        if (!!this.privIsRecognizing) {\r\n            this.privIsRecognizing = false;\r\n            await this.detachAudioNode();\r\n        }\r\n    }\r\n\r\n    private async detachAudioNode(): Promise<void> {\r\n        if (!this.privIsAudioNodeDetached) {\r\n            this.privIsAudioNodeDetached = true;\r\n            if (this.privAudioNode) {\r\n                await this.privAudioNode.detach();\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}