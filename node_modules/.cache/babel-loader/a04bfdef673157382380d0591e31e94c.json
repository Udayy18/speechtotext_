{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ArgumentNullError, ConnectionState, createNoDashGuid, EventSource, MessageType, ServiceEvent } from \"../common/Exports\";\nimport { CancellationErrorCode, CancellationReason, PropertyCollection, PropertyId, ResultReason, SpeechSynthesisBookmarkEventArgs, SpeechSynthesisEventArgs, SpeechSynthesisResult, SpeechSynthesisVisemeEventArgs, SpeechSynthesisWordBoundaryEventArgs } from \"../sdk/Exports\";\nimport { AgentConfig, CancellationErrorCodePropertyName, MetadataType, SynthesisAudioMetadata, SynthesisContext, SynthesisTurn } from \"./Exports\";\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\nexport class SynthesisAdapterBase {\n  constructor(authentication, connectionFactory, synthesizerConfig, speechSynthesizer, audioDestination) {\n    this.speakOverride = undefined;\n    this.receiveMessageOverride = undefined;\n    this.connectImplOverride = undefined;\n    this.configConnectionOverride = undefined; // A promise for a configured connection.\n    // Do not consume directly, call fetchConnection instead.\n\n    this.privConnectionConfigurationPromise = undefined;\n\n    if (!authentication) {\n      throw new ArgumentNullError(\"authentication\");\n    }\n\n    if (!connectionFactory) {\n      throw new ArgumentNullError(\"connectionFactory\");\n    }\n\n    if (!synthesizerConfig) {\n      throw new ArgumentNullError(\"synthesizerConfig\");\n    }\n\n    this.privAuthentication = authentication;\n    this.privConnectionFactory = connectionFactory;\n    this.privSynthesizerConfig = synthesizerConfig;\n    this.privIsDisposed = false;\n    this.privSpeechSynthesizer = speechSynthesizer;\n    this.privSessionAudioDestination = audioDestination;\n    this.privSynthesisTurn = new SynthesisTurn();\n    this.privConnectionEvents = new EventSource();\n    this.privServiceEvents = new EventSource();\n    this.privSynthesisContext = new SynthesisContext(this.privSpeechSynthesizer);\n    this.privAgentConfig = new AgentConfig();\n    this.connectionEvents.attach(connectionEvent => {\n      if (connectionEvent.name === \"ConnectionClosedEvent\") {\n        const connectionClosedEvent = connectionEvent;\n\n        if (connectionClosedEvent.statusCode !== 1000) {\n          this.cancelSynthesisLocal(CancellationReason.Error, connectionClosedEvent.statusCode === 1007 ? CancellationErrorCode.BadRequestParameters : CancellationErrorCode.ConnectionFailure, `${connectionClosedEvent.reason} websocket error code: ${connectionClosedEvent.statusCode}`);\n        }\n      }\n    });\n  }\n\n  get synthesisContext() {\n    return this.privSynthesisContext;\n  }\n\n  get agentConfig() {\n    return this.privAgentConfig;\n  }\n\n  get connectionEvents() {\n    return this.privConnectionEvents;\n  }\n\n  get serviceEvents() {\n    return this.privServiceEvents;\n  }\n\n  set activityTemplate(messagePayload) {\n    this.privActivityTemplate = messagePayload;\n  }\n\n  get activityTemplate() {\n    return this.privActivityTemplate;\n  }\n\n  set audioOutputFormat(format) {\n    this.privAudioOutputFormat = format;\n    this.privSynthesisTurn.audioOutputFormat = format;\n\n    if (this.privSessionAudioDestination !== undefined) {\n      this.privSessionAudioDestination.format = format;\n    }\n\n    if (this.synthesisContext !== undefined) {\n      this.synthesisContext.audioOutputFormat = format;\n    }\n  }\n\n  static addHeader(audio, format) {\n    if (!format.hasHeader) {\n      return audio;\n    }\n\n    format.updateHeader(audio.byteLength);\n    const tmp = new Uint8Array(audio.byteLength + format.header.byteLength);\n    tmp.set(new Uint8Array(format.header), 0);\n    tmp.set(new Uint8Array(audio), format.header.byteLength);\n    return tmp.buffer;\n  }\n\n  isDisposed() {\n    return this.privIsDisposed;\n  }\n\n  dispose(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privIsDisposed = true;\n\n      if (this.privSessionAudioDestination !== undefined) {\n        this.privSessionAudioDestination.close();\n      }\n\n      if (this.privConnectionConfigurationPromise !== undefined) {\n        const connection = yield this.privConnectionConfigurationPromise;\n        yield connection.dispose(reason);\n      }\n    });\n  }\n\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.connectImpl();\n    });\n  }\n\n  sendNetworkMessage(path, payload) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const type = typeof payload === \"string\" ? MessageType.Text : MessageType.Binary;\n      const contentType = typeof payload === \"string\" ? \"application/json\" : \"\";\n      const connection = yield this.fetchConnection();\n      return connection.send(new SpeechConnectionMessage(type, path, this.privSynthesisTurn.requestId, contentType, payload));\n    });\n  }\n\n  Speak(text, isSSML, requestId, successCallback, errorCallBack, audioDestination) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let ssml;\n\n      if (isSSML) {\n        ssml = text;\n      } else {\n        ssml = this.privSpeechSynthesizer.buildSsml(text);\n      }\n\n      if (this.speakOverride !== undefined) {\n        return this.speakOverride(ssml, requestId, successCallback, errorCallBack);\n      }\n\n      this.privSuccessCallback = successCallback;\n      this.privErrorCallback = errorCallBack;\n      this.privSynthesisTurn.startNewSynthesis(requestId, text, isSSML, audioDestination);\n\n      try {\n        yield this.connectImpl();\n        const connection = yield this.fetchConnection();\n        yield this.sendSynthesisContext(connection);\n        yield this.sendSsmlMessage(connection, ssml, requestId);\n        const synthesisStartEventArgs = new SpeechSynthesisEventArgs(new SpeechSynthesisResult(requestId, ResultReason.SynthesizingAudioStarted));\n\n        if (!!this.privSpeechSynthesizer.synthesisStarted) {\n          this.privSpeechSynthesizer.synthesisStarted(this.privSpeechSynthesizer, synthesisStartEventArgs);\n        }\n\n        void this.receiveMessage();\n      } catch (e) {\n        this.cancelSynthesisLocal(CancellationReason.Error, CancellationErrorCode.ConnectionFailure, e);\n        return Promise.reject(e);\n      }\n    });\n  } // Cancels synthesis.\n\n\n  cancelSynthesis(requestId, cancellationReason, errorCode, error) {\n    const properties = new PropertyCollection();\n    properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\n    const result = new SpeechSynthesisResult(requestId, ResultReason.Canceled, undefined, error, properties);\n\n    if (!!this.privSpeechSynthesizer.SynthesisCanceled) {\n      const cancelEvent = new SpeechSynthesisEventArgs(result);\n\n      try {\n        this.privSpeechSynthesizer.SynthesisCanceled(this.privSpeechSynthesizer, cancelEvent);\n        /* eslint-disable no-empty */\n      } catch (_a) {}\n    }\n\n    if (!!this.privSuccessCallback) {\n      try {\n        this.privSuccessCallback(result);\n        /* eslint-disable no-empty */\n      } catch (_b) {}\n    }\n  } // Cancels synthesis.\n\n\n  cancelSynthesisLocal(cancellationReason, errorCode, error) {\n    if (!!this.privSynthesisTurn.isSynthesizing) {\n      this.privSynthesisTurn.onStopSynthesizing();\n      this.cancelSynthesis(this.privSynthesisTurn.requestId, cancellationReason, errorCode, error);\n    }\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  processTypeSpecificMessages(connectionMessage) {\n    return true;\n  }\n\n  receiveMessage() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const connection = yield this.fetchConnection();\n        const message = yield connection.read();\n\n        if (this.receiveMessageOverride !== undefined) {\n          return this.receiveMessageOverride();\n        }\n\n        if (this.privIsDisposed) {\n          // We're done.\n          return;\n        } // indicates we are draining the queue and it came with no message;\n\n\n        if (!message) {\n          if (!this.privSynthesisTurn.isSynthesizing) {\n            return;\n          } else {\n            return this.receiveMessage();\n          }\n        }\n\n        const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\n\n        if (connectionMessage.requestId.toLowerCase() === this.privSynthesisTurn.requestId.toLowerCase()) {\n          switch (connectionMessage.path.toLowerCase()) {\n            case \"turn.start\":\n              this.privSynthesisTurn.onServiceTurnStartResponse();\n              break;\n\n            case \"response\":\n              this.privSynthesisTurn.onServiceResponseMessage(connectionMessage.textBody);\n              break;\n\n            case \"audio\":\n              if (this.privSynthesisTurn.streamId.toLowerCase() === connectionMessage.streamId.toLowerCase() && !!connectionMessage.binaryBody) {\n                this.privSynthesisTurn.onAudioChunkReceived(connectionMessage.binaryBody);\n\n                if (!!this.privSpeechSynthesizer.synthesizing) {\n                  try {\n                    const audioWithHeader = SynthesisAdapterBase.addHeader(connectionMessage.binaryBody, this.privSynthesisTurn.audioOutputFormat);\n                    const ev = new SpeechSynthesisEventArgs(new SpeechSynthesisResult(this.privSynthesisTurn.requestId, ResultReason.SynthesizingAudio, audioWithHeader));\n                    this.privSpeechSynthesizer.synthesizing(this.privSpeechSynthesizer, ev);\n                  } catch (error) {// Not going to let errors in the event handler\n                    // trip things up.\n                  }\n                }\n\n                if (this.privSessionAudioDestination !== undefined) {\n                  this.privSessionAudioDestination.write(connectionMessage.binaryBody);\n                }\n              }\n\n              break;\n\n            case \"audio.metadata\":\n              const metadataList = SynthesisAudioMetadata.fromJSON(connectionMessage.textBody).Metadata;\n\n              for (const metadata of metadataList) {\n                switch (metadata.Type) {\n                  case MetadataType.WordBoundary:\n                  case MetadataType.SentenceBoundary:\n                    this.privSynthesisTurn.onTextBoundaryEvent(metadata);\n                    const wordBoundaryEventArgs = new SpeechSynthesisWordBoundaryEventArgs(metadata.Data.Offset, metadata.Data.Duration, metadata.Data.text.Text, metadata.Data.text.Length, metadata.Type === MetadataType.WordBoundary ? this.privSynthesisTurn.currentTextOffset : this.privSynthesisTurn.currentSentenceOffset, metadata.Data.text.BoundaryType);\n\n                    if (!!this.privSpeechSynthesizer.wordBoundary) {\n                      try {\n                        this.privSpeechSynthesizer.wordBoundary(this.privSpeechSynthesizer, wordBoundaryEventArgs);\n                      } catch (error) {// Not going to let errors in the event handler\n                        // trip things up.\n                      }\n                    }\n\n                    break;\n\n                  case MetadataType.Bookmark:\n                    const bookmarkEventArgs = new SpeechSynthesisBookmarkEventArgs(metadata.Data.Offset, metadata.Data.Bookmark);\n\n                    if (!!this.privSpeechSynthesizer.bookmarkReached) {\n                      try {\n                        this.privSpeechSynthesizer.bookmarkReached(this.privSpeechSynthesizer, bookmarkEventArgs);\n                      } catch (error) {// Not going to let errors in the event handler\n                        // trip things up.\n                      }\n                    }\n\n                    break;\n\n                  case MetadataType.Viseme:\n                    this.privSynthesisTurn.onVisemeMetadataReceived(metadata);\n\n                    if (metadata.Data.IsLastAnimation) {\n                      const visemeEventArgs = new SpeechSynthesisVisemeEventArgs(metadata.Data.Offset, metadata.Data.VisemeId, this.privSynthesisTurn.getAndClearVisemeAnimation());\n\n                      if (!!this.privSpeechSynthesizer.visemeReceived) {\n                        try {\n                          this.privSpeechSynthesizer.visemeReceived(this.privSpeechSynthesizer, visemeEventArgs);\n                        } catch (error) {// Not going to let errors in the event handler\n                          // trip things up.\n                        }\n                      }\n                    }\n\n                    break;\n\n                  case MetadataType.SessionEnd:\n                    this.privSynthesisTurn.onSessionEnd(metadata);\n                    break;\n                }\n              }\n\n              break;\n\n            case \"turn.end\":\n              this.privSynthesisTurn.onServiceTurnEndResponse();\n              let result;\n\n              try {\n                const audioBuffer = yield this.privSynthesisTurn.getAllReceivedAudioWithHeader();\n                result = new SpeechSynthesisResult(this.privSynthesisTurn.requestId, ResultReason.SynthesizingAudioCompleted, audioBuffer, undefined, undefined, this.privSynthesisTurn.audioDuration);\n\n                if (!!this.privSuccessCallback) {\n                  this.privSuccessCallback(result);\n                }\n              } catch (error) {\n                if (!!this.privErrorCallback) {\n                  this.privErrorCallback(error);\n                }\n              }\n\n              if (this.privSpeechSynthesizer.synthesisCompleted) {\n                try {\n                  this.privSpeechSynthesizer.synthesisCompleted(this.privSpeechSynthesizer, new SpeechSynthesisEventArgs(result));\n                } catch (e) {// Not going to let errors in the event handler\n                  // trip things up.\n                }\n              }\n\n              break;\n\n            default:\n              if (!this.processTypeSpecificMessages(connectionMessage)) {\n                // here are some messages that the derived class has not processed, dispatch them to connect class\n                if (!!this.privServiceEvents) {\n                  this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\n                }\n              }\n\n          }\n        }\n\n        return this.receiveMessage();\n      } catch (e) {// TODO: What goes here?\n      }\n    });\n  }\n\n  sendSynthesisContext(connection) {\n    const synthesisContextJson = this.synthesisContext.toJSON();\n\n    if (synthesisContextJson) {\n      return connection.send(new SpeechConnectionMessage(MessageType.Text, \"synthesis.context\", this.privSynthesisTurn.requestId, \"application/json\", synthesisContextJson));\n    }\n\n    return;\n  }\n\n  connectImpl(isUnAuthorized = false) {\n    if (this.privConnectionPromise != null) {\n      return this.privConnectionPromise.then(connection => {\n        if (connection.state() === ConnectionState.Disconnected) {\n          this.privConnectionId = null;\n          this.privConnectionPromise = null;\n          return this.connectImpl();\n        }\n\n        return this.privConnectionPromise;\n      }, () => {\n        this.privConnectionId = null;\n        this.privConnectionPromise = null;\n        return this.connectImpl();\n      });\n    }\n\n    this.privAuthFetchEventId = createNoDashGuid();\n    this.privConnectionId = createNoDashGuid();\n    this.privSynthesisTurn.onPreConnectionStart(this.privAuthFetchEventId);\n    const authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);\n    this.privConnectionPromise = authPromise.then(result => __awaiter(this, void 0, void 0, function* () {\n      this.privSynthesisTurn.onAuthCompleted(false);\n      const connection = this.privConnectionFactory.create(this.privSynthesizerConfig, result, this.privConnectionId); // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\n      // it'll stop sending events.\n\n      connection.events.attach(event => {\n        this.connectionEvents.onEvent(event);\n      });\n      const response = yield connection.open();\n\n      if (response.statusCode === 200) {\n        this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);\n        return Promise.resolve(connection);\n      } else if (response.statusCode === 403 && !isUnAuthorized) {\n        return this.connectImpl(true);\n      } else {\n        this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);\n        return Promise.reject(`Unable to contact server. StatusCode: ${response.statusCode}, ${this.privSynthesizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${response.reason}`);\n      }\n    }), error => {\n      this.privSynthesisTurn.onAuthCompleted(true);\n      throw new Error(error);\n    }); // Attach an empty handler to allow the promise to run in the background while\n    // other startup events happen. It'll eventually be awaited on.\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n    this.privConnectionPromise.catch(() => {});\n    return this.privConnectionPromise;\n  }\n\n  sendSpeechServiceConfig(connection, SpeechServiceConfigJson) {\n    if (SpeechServiceConfigJson) {\n      return connection.send(new SpeechConnectionMessage(MessageType.Text, \"speech.config\", this.privSynthesisTurn.requestId, \"application/json\", SpeechServiceConfigJson));\n    }\n  }\n\n  sendSsmlMessage(connection, ssml, requestId) {\n    return connection.send(new SpeechConnectionMessage(MessageType.Text, \"ssml\", requestId, \"application/ssml+xml\", ssml));\n  }\n\n  fetchConnection() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.privConnectionConfigurationPromise !== undefined) {\n        return this.privConnectionConfigurationPromise.then(connection => {\n          if (connection.state() === ConnectionState.Disconnected) {\n            this.privConnectionId = null;\n            this.privConnectionConfigurationPromise = undefined;\n            return this.fetchConnection();\n          }\n\n          return this.privConnectionConfigurationPromise;\n        }, () => {\n          this.privConnectionId = null;\n          this.privConnectionConfigurationPromise = undefined;\n          return this.fetchConnection();\n        });\n      }\n\n      this.privConnectionConfigurationPromise = this.configureConnection();\n      return yield this.privConnectionConfigurationPromise;\n    });\n  } // Takes an established websocket connection to the endpoint and sends speech configuration information.\n\n\n  configureConnection() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.connectImpl();\n\n      if (this.configConnectionOverride !== undefined) {\n        return this.configConnectionOverride(connection);\n      }\n\n      yield this.sendSpeechServiceConfig(connection, this.privSynthesizerConfig.SpeechServiceConfig.serialize());\n      return connection;\n    });\n  }\n\n}\nSynthesisAdapterBase.telemetryDataEnabled = true;","map":{"version":3,"sources":["src/common.speech/SynthesisAdapterBase.ts"],"names":[],"mappings":"AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,SACI,iBADJ,EAKI,eALJ,EAMI,gBANJ,EAOI,WAPJ,EAWI,WAXJ,EAYI,YAZJ,QAaO,mBAbP;AAeA,SACI,qBADJ,EAEI,kBAFJ,EAGI,kBAHJ,EAII,UAJJ,EAKI,YALJ,EAMI,gCANJ,EAOI,wBAPJ,EAQI,qBARJ,EASI,8BATJ,EAUI,oCAVJ,QAYO,gBAZP;AAaA,SACI,WADJ,EAEI,iCAFJ,EAII,YAJJ,EAKI,sBALJ,EAMI,gBANJ,EAOI,aAPJ,QASO,WATP;AAWA,SAAS,uBAAT,QAAwC,oCAAxC;AAEA,OAAM,MAAO,oBAAP,CAA2B;AA0E7B,EAAA,WAAA,CACI,cADJ,EAEI,iBAFJ,EAGI,iBAHJ,EAII,iBAJJ,EAKI,gBALJ,EAKuC;AAvD7B,SAAA,aAAA,GAA4H,SAA5H;AAcA,SAAA,sBAAA,GAAqC,SAArC;AAEA,SAAA,mBAAA,GAAyD,SAAzD;AAEA,SAAA,wBAAA,GAA8E,SAA9E,CAqC6B,CAtBvC;AACA;;AACQ,SAAA,kCAAA,GAA2D,SAA3D;;AAsBJ,QAAI,CAAC,cAAL,EAAqB;AACjB,YAAM,IAAI,iBAAJ,CAAsB,gBAAtB,CAAN;AACH;;AAED,QAAI,CAAC,iBAAL,EAAwB;AACpB,YAAM,IAAI,iBAAJ,CAAsB,mBAAtB,CAAN;AACH;;AAED,QAAI,CAAC,iBAAL,EAAwB;AACpB,YAAM,IAAI,iBAAJ,CAAsB,mBAAtB,CAAN;AACH;;AAED,SAAK,kBAAL,GAA0B,cAA1B;AACA,SAAK,qBAAL,GAA6B,iBAA7B;AACA,SAAK,qBAAL,GAA6B,iBAA7B;AACA,SAAK,cAAL,GAAsB,KAAtB;AACA,SAAK,qBAAL,GAA6B,iBAA7B;AACA,SAAK,2BAAL,GAAmC,gBAAnC;AACA,SAAK,iBAAL,GAAyB,IAAI,aAAJ,EAAzB;AACA,SAAK,oBAAL,GAA4B,IAAI,WAAJ,EAA5B;AACA,SAAK,iBAAL,GAAyB,IAAI,WAAJ,EAAzB;AACA,SAAK,oBAAL,GAA4B,IAAI,gBAAJ,CAAqB,KAAK,qBAA1B,CAA5B;AACA,SAAK,eAAL,GAAuB,IAAI,WAAJ,EAAvB;AAEA,SAAK,gBAAL,CAAsB,MAAtB,CAA8B,eAAD,IAA2C;AACpE,UAAI,eAAe,CAAC,IAAhB,KAAyB,uBAA7B,EAAsD;AAClD,cAAM,qBAAqB,GAAG,eAA9B;;AACA,YAAI,qBAAqB,CAAC,UAAtB,KAAqC,IAAzC,EAA+C;AAC3C,eAAK,oBAAL,CAA0B,kBAAkB,CAAC,KAA7C,EACI,qBAAqB,CAAC,UAAtB,KAAqC,IAArC,GAA4C,qBAAqB,CAAC,oBAAlE,GAAyF,qBAAqB,CAAC,iBADnH,EAEI,GAAG,qBAAqB,CAAC,MAAM,0BAA0B,qBAAqB,CAAC,UAAU,EAF7F;AAGH;AACJ;AACJ,KATD;AAUH;;AA3GD,MAAW,gBAAX,GAA2B;AACvB,WAAO,KAAK,oBAAZ;AACH;;AAED,MAAW,WAAX,GAAsB;AAClB,WAAO,KAAK,eAAZ;AACH;;AAED,MAAW,gBAAX,GAA2B;AACvB,WAAO,KAAK,oBAAZ;AACH;;AAED,MAAW,aAAX,GAAwB;AACpB,WAAO,KAAK,iBAAZ;AACH;;AASD,MAAW,gBAAX,CAA4B,cAA5B,EAAkD;AAC9C,SAAK,oBAAL,GAA4B,cAA5B;AACH;;AACD,MAAW,gBAAX,GAA2B;AACvB,WAAO,KAAK,oBAAZ;AACH;;AAQD,MAAW,iBAAX,CAA6B,MAA7B,EAA0D;AACtD,SAAK,qBAAL,GAA6B,MAA7B;AACA,SAAK,iBAAL,CAAuB,iBAAvB,GAA2C,MAA3C;;AACA,QAAI,KAAK,2BAAL,KAAqC,SAAzC,EAAoD;AAChD,WAAK,2BAAL,CAAiC,MAAjC,GAA0C,MAA1C;AACH;;AACD,QAAI,KAAK,gBAAL,KAA0B,SAA9B,EAAyC;AACrC,WAAK,gBAAL,CAAsB,iBAAtB,GAA0C,MAA1C;AACH;AACJ;;AAgEM,SAAO,SAAP,CAAiB,KAAjB,EAAqC,MAArC,EAAkE;AACrE,QAAI,CAAC,MAAM,CAAC,SAAZ,EAAuB;AACnB,aAAO,KAAP;AACH;;AACD,IAAA,MAAM,CAAC,YAAP,CAAoB,KAAK,CAAC,UAA1B;AACA,UAAM,GAAG,GAAG,IAAI,UAAJ,CAAe,KAAK,CAAC,UAAN,GAAmB,MAAM,CAAC,MAAP,CAAc,UAAhD,CAAZ;AACA,IAAA,GAAG,CAAC,GAAJ,CAAQ,IAAI,UAAJ,CAAe,MAAM,CAAC,MAAtB,CAAR,EAAuC,CAAvC;AACA,IAAA,GAAG,CAAC,GAAJ,CAAQ,IAAI,UAAJ,CAAe,KAAf,CAAR,EAA+B,MAAM,CAAC,MAAP,CAAc,UAA7C;AACA,WAAO,GAAG,CAAC,MAAX;AACH;;AAEM,EAAA,UAAU,GAAA;AACb,WAAO,KAAK,cAAZ;AACH;;AAEY,EAAA,OAAO,CAAC,MAAD,EAAgB;;AAChC,WAAK,cAAL,GAAsB,IAAtB;;AACA,UAAI,KAAK,2BAAL,KAAqC,SAAzC,EAAoD;AAChD,aAAK,2BAAL,CAAiC,KAAjC;AACH;;AACD,UAAI,KAAK,kCAAL,KAA4C,SAAhD,EAA2D;AACvD,cAAM,UAAU,GAAgB,MAAM,KAAK,kCAA3C;AACA,cAAM,UAAU,CAAC,OAAX,CAAmB,MAAnB,CAAN;AACH;AACJ,K;AAAA;;AAEY,EAAA,OAAO,GAAA;;AAChB,YAAM,KAAK,WAAL,EAAN;AACH,K;AAAA;;AAEY,EAAA,kBAAkB,CAAC,IAAD,EAAe,OAAf,EAA4C;;AACvE,YAAM,IAAI,GAAgB,OAAO,OAAP,KAAmB,QAAnB,GAA8B,WAAW,CAAC,IAA1C,GAAiD,WAAW,CAAC,MAAvF;AACA,YAAM,WAAW,GAAW,OAAO,OAAP,KAAmB,QAAnB,GAA8B,kBAA9B,GAAmD,EAA/E;AAEA,YAAM,UAAU,GAAgB,MAAM,KAAK,eAAL,EAAtC;AACA,aAAO,UAAU,CAAC,IAAX,CAAgB,IAAI,uBAAJ,CAA4B,IAA5B,EAAkC,IAAlC,EAAwC,KAAK,iBAAL,CAAuB,SAA/D,EAA0E,WAA1E,EAAuF,OAAvF,CAAhB,CAAP;AACH,K;AAAA;;AAEY,EAAA,KAAK,CACd,IADc,EAEd,MAFc,EAGd,SAHc,EAId,eAJc,EAKd,aALc,EAMd,gBANc,EAMqB;;AAGnC,UAAI,IAAJ;;AAEA,UAAI,MAAJ,EAAY;AACR,QAAA,IAAI,GAAG,IAAP;AACH,OAFD,MAEO;AACH,QAAA,IAAI,GAAG,KAAK,qBAAL,CAA2B,SAA3B,CAAqC,IAArC,CAAP;AACH;;AAED,UAAI,KAAK,aAAL,KAAuB,SAA3B,EAAsC;AAClC,eAAO,KAAK,aAAL,CAAmB,IAAnB,EAAyB,SAAzB,EAAoC,eAApC,EAAqD,aAArD,CAAP;AACH;;AAED,WAAK,mBAAL,GAA2B,eAA3B;AACA,WAAK,iBAAL,GAAyB,aAAzB;AAEA,WAAK,iBAAL,CAAuB,iBAAvB,CAAyC,SAAzC,EAAoD,IAApD,EAA0D,MAA1D,EAAkE,gBAAlE;;AAEA,UAAI;AACA,cAAM,KAAK,WAAL,EAAN;AACA,cAAM,UAAU,GAAgB,MAAM,KAAK,eAAL,EAAtC;AACA,cAAM,KAAK,oBAAL,CAA0B,UAA1B,CAAN;AACA,cAAM,KAAK,eAAL,CAAqB,UAArB,EAAiC,IAAjC,EAAuC,SAAvC,CAAN;AACA,cAAM,uBAAuB,GAA6B,IAAI,wBAAJ,CACtD,IAAI,qBAAJ,CACI,SADJ,EAEI,YAAY,CAAC,wBAFjB,CADsD,CAA1D;;AAOA,YAAI,CAAC,CAAC,KAAK,qBAAL,CAA2B,gBAAjC,EAAmD;AAC/C,eAAK,qBAAL,CAA2B,gBAA3B,CAA4C,KAAK,qBAAjD,EAAwE,uBAAxE;AACH;;AAED,aAAK,KAAK,cAAL,EAAL;AACH,OAjBD,CAiBE,OAAO,CAAP,EAAU;AACR,aAAK,oBAAL,CAA0B,kBAAkB,CAAC,KAA7C,EAAoD,qBAAqB,CAAC,iBAA1E,EAA6F,CAA7F;AACA,eAAO,OAAO,CAAC,MAAR,CAAe,CAAf,CAAP;AACH;AACJ,K;AAAA,GA1M4B,CA4M7B;;;AACU,EAAA,eAAe,CACrB,SADqB,EAErB,kBAFqB,EAGrB,SAHqB,EAIrB,KAJqB,EAIR;AACb,UAAM,UAAU,GAAuB,IAAI,kBAAJ,EAAvC;AACA,IAAA,UAAU,CAAC,WAAX,CAAuB,iCAAvB,EAA0D,qBAAqB,CAAC,SAAD,CAA/E;AACA,UAAM,MAAM,GAA0B,IAAI,qBAAJ,CAClC,SADkC,EAElC,YAAY,CAAC,QAFqB,EAGlC,SAHkC,EAIlC,KAJkC,EAKlC,UALkC,CAAtC;;AAQA,QAAI,CAAC,CAAC,KAAK,qBAAL,CAA2B,iBAAjC,EAAoD;AAChD,YAAM,WAAW,GAA6B,IAAI,wBAAJ,CAA6B,MAA7B,CAA9C;;AACA,UAAI;AACA,aAAK,qBAAL,CAA2B,iBAA3B,CAA6C,KAAK,qBAAlD,EAAyE,WAAzE;AACA;AACH,OAHD,CAGE,OAAA,EAAA,EAAM,CAAG;AACd;;AAED,QAAI,CAAC,CAAC,KAAK,mBAAX,EAAgC;AAC5B,UAAI;AACA,aAAK,mBAAL,CAAyB,MAAzB;AACA;AACH,OAHD,CAGE,OAAA,EAAA,EAAM,CAAG;AACd;AACJ,GA1O4B,CA4O7B;;;AACU,EAAA,oBAAoB,CAC1B,kBAD0B,EAE1B,SAF0B,EAG1B,KAH0B,EAGb;AAEb,QAAI,CAAC,CAAC,KAAK,iBAAL,CAAuB,cAA7B,EAA6C;AACzC,WAAK,iBAAL,CAAuB,kBAAvB;AAEA,WAAK,eAAL,CACI,KAAK,iBAAL,CAAuB,SAD3B,EAEI,kBAFJ,EAGI,SAHJ,EAII,KAJJ;AAKH;AACJ,GA3P4B,CA6P7B;;;AACU,EAAA,2BAA2B,CAAC,iBAAD,EAA2C;AAC5E,WAAO,IAAP;AACH;;AAEe,EAAA,cAAc,GAAA;;AAC1B,UAAI;AACA,cAAM,UAAU,GAAgB,MAAM,KAAK,eAAL,EAAtC;AACA,cAAM,OAAO,GAAsB,MAAM,UAAU,CAAC,IAAX,EAAzC;;AAEA,YAAI,KAAK,sBAAL,KAAgC,SAApC,EAA+C;AAC3C,iBAAO,KAAK,sBAAL,EAAP;AACH;;AACD,YAAI,KAAK,cAAT,EAAyB;AACrB;AACA;AACH,SAVD,CAYA;;;AACA,YAAI,CAAC,OAAL,EAAc;AACV,cAAI,CAAC,KAAK,iBAAL,CAAuB,cAA5B,EAA4C;AACxC;AACH,WAFD,MAEO;AACH,mBAAO,KAAK,cAAL,EAAP;AACH;AACJ;;AAGD,cAAM,iBAAiB,GAAG,uBAAuB,CAAC,qBAAxB,CAA8C,OAA9C,CAA1B;;AAEA,YAAI,iBAAiB,CAAC,SAAlB,CAA4B,WAA5B,OAA8C,KAAK,iBAAL,CAAuB,SAAvB,CAAiC,WAAjC,EAAlD,EAAkG;AAC9F,kBAAQ,iBAAiB,CAAC,IAAlB,CAAuB,WAAvB,EAAR;AACI,iBAAK,YAAL;AACI,mBAAK,iBAAL,CAAuB,0BAAvB;AACA;;AACJ,iBAAK,UAAL;AACI,mBAAK,iBAAL,CAAuB,wBAAvB,CAAgD,iBAAiB,CAAC,QAAlE;AACA;;AACJ,iBAAK,OAAL;AACI,kBAAI,KAAK,iBAAL,CAAuB,QAAvB,CAAgC,WAAhC,OAAkD,iBAAiB,CAAC,QAAlB,CAA2B,WAA3B,EAAlD,IACG,CAAC,CAAC,iBAAiB,CAAC,UAD3B,EACuC;AACnC,qBAAK,iBAAL,CAAuB,oBAAvB,CAA4C,iBAAiB,CAAC,UAA9D;;AACA,oBAAI,CAAC,CAAC,KAAK,qBAAL,CAA2B,YAAjC,EAA+C;AAC3C,sBAAI;AACA,0BAAM,eAAe,GAAG,oBAAoB,CAAC,SAArB,CAA+B,iBAAiB,CAAC,UAAjD,EAA6D,KAAK,iBAAL,CAAuB,iBAApF,CAAxB;AACA,0BAAM,EAAE,GAA6B,IAAI,wBAAJ,CACjC,IAAI,qBAAJ,CACI,KAAK,iBAAL,CAAuB,SAD3B,EAEI,YAAY,CAAC,iBAFjB,EAGI,eAHJ,CADiC,CAArC;AAKA,yBAAK,qBAAL,CAA2B,YAA3B,CAAwC,KAAK,qBAA7C,EAAoE,EAApE;AACH,mBARD,CAQE,OAAO,KAAP,EAAc,CACZ;AACA;AACH;AACJ;;AACD,oBAAI,KAAK,2BAAL,KAAqC,SAAzC,EAAoD;AAChD,uBAAK,2BAAL,CAAiC,KAAjC,CAAuC,iBAAiB,CAAC,UAAzD;AACH;AACJ;;AACD;;AACJ,iBAAK,gBAAL;AACI,oBAAM,YAAY,GAAG,sBAAsB,CAAC,QAAvB,CAAgC,iBAAiB,CAAC,QAAlD,EAA4D,QAAjF;;AACA,mBAAK,MAAM,QAAX,IAAuB,YAAvB,EAAqC;AACjC,wBAAQ,QAAQ,CAAC,IAAjB;AACI,uBAAK,YAAY,CAAC,YAAlB;AACA,uBAAK,YAAY,CAAC,gBAAlB;AACI,yBAAK,iBAAL,CAAuB,mBAAvB,CAA2C,QAA3C;AAEA,0BAAM,qBAAqB,GAAyC,IAAI,oCAAJ,CAChE,QAAQ,CAAC,IAAT,CAAc,MADkD,EAEhE,QAAQ,CAAC,IAAT,CAAc,QAFkD,EAGhE,QAAQ,CAAC,IAAT,CAAc,IAAd,CAAmB,IAH6C,EAIhE,QAAQ,CAAC,IAAT,CAAc,IAAd,CAAmB,MAJ6C,EAKhE,QAAQ,CAAC,IAAT,KAAkB,YAAY,CAAC,YAA/B,GACM,KAAK,iBAAL,CAAuB,iBAD7B,GACiD,KAAK,iBAAL,CAAuB,qBANR,EAOhE,QAAQ,CAAC,IAAT,CAAc,IAAd,CAAmB,YAP6C,CAApE;;AASA,wBAAI,CAAC,CAAC,KAAK,qBAAL,CAA2B,YAAjC,EAA+C;AAC3C,0BAAI;AACA,6BAAK,qBAAL,CAA2B,YAA3B,CAAwC,KAAK,qBAA7C,EAAoE,qBAApE;AACH,uBAFD,CAEE,OAAO,KAAP,EAAc,CACZ;AACA;AACH;AACJ;;AACD;;AACJ,uBAAK,YAAY,CAAC,QAAlB;AACI,0BAAM,iBAAiB,GAAqC,IAAI,gCAAJ,CACxD,QAAQ,CAAC,IAAT,CAAc,MAD0C,EAExD,QAAQ,CAAC,IAAT,CAAc,QAF0C,CAA5D;;AAIA,wBAAI,CAAC,CAAC,KAAK,qBAAL,CAA2B,eAAjC,EAAkD;AAC9C,0BAAI;AACA,6BAAK,qBAAL,CAA2B,eAA3B,CAA2C,KAAK,qBAAhD,EAAuE,iBAAvE;AACH,uBAFD,CAEE,OAAO,KAAP,EAAc,CACZ;AACA;AACH;AACJ;;AACD;;AACJ,uBAAK,YAAY,CAAC,MAAlB;AACI,yBAAK,iBAAL,CAAuB,wBAAvB,CAAgD,QAAhD;;AACA,wBAAI,QAAQ,CAAC,IAAT,CAAc,eAAlB,EAAmC;AAC/B,4BAAM,eAAe,GAAmC,IAAI,8BAAJ,CACpD,QAAQ,CAAC,IAAT,CAAc,MADsC,EAEpD,QAAQ,CAAC,IAAT,CAAc,QAFsC,EAGpD,KAAK,iBAAL,CAAuB,0BAAvB,EAHoD,CAAxD;;AAKA,0BAAI,CAAC,CAAC,KAAK,qBAAL,CAA2B,cAAjC,EAAiD;AAC7C,4BAAI;AACA,+BAAK,qBAAL,CAA2B,cAA3B,CAA0C,KAAK,qBAA/C,EAAsE,eAAtE;AACH,yBAFD,CAEE,OAAO,KAAP,EAAc,CACZ;AACA;AACH;AACJ;AACJ;;AACD;;AACJ,uBAAK,YAAY,CAAC,UAAlB;AACI,yBAAK,iBAAL,CAAuB,YAAvB,CAAoC,QAApC;AACA;AAzDR;AA2DH;;AACD;;AACJ,iBAAK,UAAL;AACI,mBAAK,iBAAL,CAAuB,wBAAvB;AACA,kBAAI,MAAJ;;AACA,kBAAI;AACA,sBAAM,WAAW,GAAgB,MAAM,KAAK,iBAAL,CAAuB,6BAAvB,EAAvC;AACA,gBAAA,MAAM,GAAG,IAAI,qBAAJ,CACL,KAAK,iBAAL,CAAuB,SADlB,EAEL,YAAY,CAAC,0BAFR,EAGL,WAHK,EAIL,SAJK,EAKL,SALK,EAML,KAAK,iBAAL,CAAuB,aANlB,CAAT;;AAQA,oBAAI,CAAC,CAAC,KAAK,mBAAX,EAAgC;AAC5B,uBAAK,mBAAL,CAAyB,MAAzB;AACH;AACJ,eAbD,CAaE,OAAO,KAAP,EAAc;AACZ,oBAAI,CAAC,CAAC,KAAK,iBAAX,EAA8B;AAC1B,uBAAK,iBAAL,CAAuB,KAAvB;AACH;AACJ;;AACD,kBAAI,KAAK,qBAAL,CAA2B,kBAA/B,EAAmD;AAC/C,oBAAI;AACA,uBAAK,qBAAL,CAA2B,kBAA3B,CACI,KAAK,qBADT,EAEI,IAAI,wBAAJ,CAA6B,MAA7B,CAFJ;AAIH,iBALD,CAKE,OAAO,CAAP,EAAU,CACR;AACA;AACH;AACJ;;AACD;;AAEJ;AAEI,kBAAI,CAAC,KAAK,2BAAL,CAAiC,iBAAjC,CAAL,EAA0D;AACtD;AACA,oBAAI,CAAC,CAAC,KAAK,iBAAX,EAA8B;AAC1B,uBAAK,aAAL,CAAmB,OAAnB,CAA2B,IAAI,YAAJ,CAAiB,iBAAiB,CAAC,IAAlB,CAAuB,WAAvB,EAAjB,EAAuD,iBAAiB,CAAC,QAAzE,CAA3B;AACH;AACJ;;AAvIT;AA0IH;;AAED,eAAO,KAAK,cAAL,EAAP;AAEH,OAvKD,CAuKE,OAAO,CAAP,EAAU,CACR;AACH;AACJ,K;AAAA;;AAES,EAAA,oBAAoB,CAAC,UAAD,EAAwB;AAClD,UAAM,oBAAoB,GAAG,KAAK,gBAAL,CAAsB,MAAtB,EAA7B;;AAEA,QAAI,oBAAJ,EAA0B;AACtB,aAAO,UAAU,CAAC,IAAX,CAAgB,IAAI,uBAAJ,CACnB,WAAW,CAAC,IADO,EAEnB,mBAFmB,EAGnB,KAAK,iBAAL,CAAuB,SAHJ,EAInB,kBAJmB,EAKnB,oBALmB,CAAhB,CAAP;AAMH;;AACD;AACH;;AAES,EAAA,WAAW,CAAC,cAAA,GAA0B,KAA3B,EAAgC;AACjD,QAAI,KAAK,qBAAL,IAA8B,IAAlC,EAAwC;AACpC,aAAO,KAAK,qBAAL,CAA2B,IAA3B,CAAiC,UAAD,IAAkD;AACrF,YAAI,UAAU,CAAC,KAAX,OAAuB,eAAe,CAAC,YAA3C,EAAyD;AACrD,eAAK,gBAAL,GAAwB,IAAxB;AACA,eAAK,qBAAL,GAA6B,IAA7B;AACA,iBAAO,KAAK,WAAL,EAAP;AACH;;AACD,eAAO,KAAK,qBAAZ;AACH,OAPM,EAOJ,MAA2B;AAC1B,aAAK,gBAAL,GAAwB,IAAxB;AACA,aAAK,qBAAL,GAA6B,IAA7B;AACA,eAAO,KAAK,WAAL,EAAP;AACH,OAXM,CAAP;AAYH;;AACD,SAAK,oBAAL,GAA4B,gBAAgB,EAA5C;AACA,SAAK,gBAAL,GAAwB,gBAAgB,EAAxC;AAEA,SAAK,iBAAL,CAAuB,oBAAvB,CAA4C,KAAK,oBAAjD;AAEA,UAAM,WAAW,GAAG,cAAc,GAAG,KAAK,kBAAL,CAAwB,aAAxB,CAAsC,KAAK,oBAA3C,CAAH,GAAsE,KAAK,kBAAL,CAAwB,KAAxB,CAA8B,KAAK,oBAAnC,CAAxG;AAEA,SAAK,qBAAL,GAA6B,WAAW,CAAC,IAAZ,CAAwB,MAAP,IAAiD,SAAA,CAAA,IAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;AAC3F,WAAK,iBAAL,CAAuB,eAAvB,CAAuC,KAAvC;AAEA,YAAM,UAAU,GAAgB,KAAK,qBAAL,CAA2B,MAA3B,CAAkC,KAAK,qBAAvC,EAA8D,MAA9D,EAAsE,KAAK,gBAA3E,CAAhC,CAH2F,CAK3F;AACA;;AACA,MAAA,UAAU,CAAC,MAAX,CAAkB,MAAlB,CAA0B,KAAD,IAAiC;AACtD,aAAK,gBAAL,CAAsB,OAAtB,CAA8B,KAA9B;AACH,OAFD;AAGA,YAAM,QAAQ,GAAG,MAAM,UAAU,CAAC,IAAX,EAAvB;;AACA,UAAI,QAAQ,CAAC,UAAT,KAAwB,GAA5B,EAAiC;AAC7B,aAAK,iBAAL,CAAuB,8BAAvB,CAAsD,QAAQ,CAAC,UAA/D;AACA,eAAO,OAAO,CAAC,OAAR,CAAgB,UAAhB,CAAP;AACH,OAHD,MAGO,IAAI,QAAQ,CAAC,UAAT,KAAwB,GAAxB,IAA+B,CAAC,cAApC,EAAoD;AACvD,eAAO,KAAK,WAAL,CAAiB,IAAjB,CAAP;AACH,OAFM,MAEA;AACH,aAAK,iBAAL,CAAuB,8BAAvB,CAAsD,QAAQ,CAAC,UAA/D;AACA,eAAO,OAAO,CAAC,MAAR,CAAe,yCAAyC,QAAQ,CAAC,UAAU,KAAK,KAAK,qBAAL,CAA2B,UAA3B,CAAsC,WAAtC,CAAkD,UAAU,CAAC,gCAA7D,CAA8F,YAAY,QAAQ,CAAC,MAAM,EAAzM,CAAP;AACH;AACJ,KApB8F,CAAlE,EAoBzB,KAAD,IAAwC;AACvC,WAAK,iBAAL,CAAuB,eAAvB,CAAuC,IAAvC;AACA,YAAM,IAAI,KAAJ,CAAU,KAAV,CAAN;AACH,KAvB4B,CAA7B,CAtBiD,CA+CjD;AACA;AACA;;AACA,SAAK,qBAAL,CAA2B,KAA3B,CAAiC,MAAW,CAAI,CAAhD;AAEA,WAAO,KAAK,qBAAZ;AACH;;AACS,EAAA,uBAAuB,CAAC,UAAD,EAA0B,uBAA1B,EAAyD;AACtF,QAAI,uBAAJ,EAA6B;AACzB,aAAO,UAAU,CAAC,IAAX,CAAgB,IAAI,uBAAJ,CACnB,WAAW,CAAC,IADO,EAEnB,eAFmB,EAGnB,KAAK,iBAAL,CAAuB,SAHJ,EAInB,kBAJmB,EAKnB,uBALmB,CAAhB,CAAP;AAMH;AACJ;;AAES,EAAA,eAAe,CAAC,UAAD,EAA0B,IAA1B,EAAwC,SAAxC,EAAyD;AAC9E,WAAO,UAAU,CAAC,IAAX,CAAgB,IAAI,uBAAJ,CACnB,WAAW,CAAC,IADO,EAEnB,MAFmB,EAGnB,SAHmB,EAInB,sBAJmB,EAKnB,IALmB,CAAhB,CAAP;AAMH;;AAEa,EAAA,eAAe,GAAA;;AACzB,UAAI,KAAK,kCAAL,KAA4C,SAAhD,EAA2D;AACvD,eAAO,KAAK,kCAAL,CAAwC,IAAxC,CAA8C,UAAD,IAAkD;AAClG,cAAI,UAAU,CAAC,KAAX,OAAuB,eAAe,CAAC,YAA3C,EAAyD;AACrD,iBAAK,gBAAL,GAAwB,IAAxB;AACA,iBAAK,kCAAL,GAA0C,SAA1C;AACA,mBAAO,KAAK,eAAL,EAAP;AACH;;AACD,iBAAO,KAAK,kCAAZ;AACH,SAPM,EAOJ,MAA2B;AAC1B,eAAK,gBAAL,GAAwB,IAAxB;AACA,eAAK,kCAAL,GAA0C,SAA1C;AACA,iBAAO,KAAK,eAAL,EAAP;AACH,SAXM,CAAP;AAYH;;AACD,WAAK,kCAAL,GAA0C,KAAK,mBAAL,EAA1C;AACA,aAAO,MAAM,KAAK,kCAAlB;AACH,K;AAAA,GAxhB4B,CA0hB7B;;;AACc,EAAA,mBAAmB,GAAA;;AAC7B,YAAM,UAAU,GAAgB,MAAM,KAAK,WAAL,EAAtC;;AACA,UAAI,KAAK,wBAAL,KAAkC,SAAtC,EAAiD;AAC7C,eAAO,KAAK,wBAAL,CAA8B,UAA9B,CAAP;AACH;;AACD,YAAM,KAAK,uBAAL,CAA6B,UAA7B,EAAyC,KAAK,qBAAL,CAA2B,mBAA3B,CAA+C,SAA/C,EAAzC,CAAN;AACA,aAAO,UAAP;AACH,K;AAAA;;AAliB4B;AA6Bf,oBAAA,CAAA,oBAAA,GAAgC,IAAhC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ArgumentNullError,\r\n    ConnectionClosedEvent,\r\n    ConnectionEvent,\r\n    ConnectionMessage,\r\n    ConnectionState,\r\n    createNoDashGuid,\r\n    EventSource,\r\n    IAudioDestination,\r\n    IConnection,\r\n    IDisposable,\r\n    MessageType,\r\n    ServiceEvent,\r\n} from \"../common/Exports\";\r\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat\";\r\nimport {\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    ResultReason,\r\n    SpeechSynthesisBookmarkEventArgs,\r\n    SpeechSynthesisEventArgs,\r\n    SpeechSynthesisResult,\r\n    SpeechSynthesisVisemeEventArgs,\r\n    SpeechSynthesisWordBoundaryEventArgs,\r\n    SpeechSynthesizer,\r\n} from \"../sdk/Exports\";\r\nimport {\r\n    AgentConfig,\r\n    CancellationErrorCodePropertyName,\r\n    ISynthesisConnectionFactory,\r\n    MetadataType,\r\n    SynthesisAudioMetadata,\r\n    SynthesisContext,\r\n    SynthesisTurn,\r\n    SynthesizerConfig\r\n} from \"./Exports\";\r\nimport { AuthInfo, IAuthentication } from \"./IAuthentication\";\r\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\r\n\r\nexport class SynthesisAdapterBase implements IDisposable {\r\n    protected privSynthesisTurn: SynthesisTurn;\r\n    protected privConnectionId: string;\r\n    protected privSynthesizerConfig: SynthesizerConfig;\r\n    protected privSpeechSynthesizer: SpeechSynthesizer;\r\n    protected privSuccessCallback: (e: SpeechSynthesisResult) => void;\r\n    protected privErrorCallback: (e: string) => void;\r\n\r\n    public get synthesisContext(): SynthesisContext {\r\n        return this.privSynthesisContext;\r\n    }\r\n\r\n    public get agentConfig(): AgentConfig {\r\n        return this.privAgentConfig;\r\n    }\r\n\r\n    public get connectionEvents(): EventSource<ConnectionEvent> {\r\n        return this.privConnectionEvents;\r\n    }\r\n\r\n    public get serviceEvents(): EventSource<ServiceEvent> {\r\n        return this.privServiceEvents;\r\n    }\r\n\r\n    protected speakOverride: (ssml: string, requestId: string, sc: (e: SpeechSynthesisResult) => void, ec: (e: string) => void) => void = undefined;\r\n\r\n    // Called when telemetry data is sent to the service.\r\n    // Used for testing Telemetry capture.\r\n    public static telemetryData: (json: string) => void;\r\n    public static telemetryDataEnabled: boolean = true;\r\n\r\n    public set activityTemplate(messagePayload: string) {\r\n        this.privActivityTemplate = messagePayload;\r\n    }\r\n    public get activityTemplate(): string {\r\n        return this.privActivityTemplate;\r\n    }\r\n\r\n    protected receiveMessageOverride: () => void = undefined;\r\n\r\n    protected connectImplOverride: (isUnAuthorized: boolean) => void = undefined;\r\n\r\n    protected configConnectionOverride: (connection: IConnection) => Promise<IConnection> = undefined;\r\n\r\n    public set audioOutputFormat(format: AudioOutputFormatImpl) {\r\n        this.privAudioOutputFormat = format;\r\n        this.privSynthesisTurn.audioOutputFormat = format;\r\n        if (this.privSessionAudioDestination !== undefined) {\r\n            this.privSessionAudioDestination.format = format;\r\n        }\r\n        if (this.synthesisContext !== undefined) {\r\n            this.synthesisContext.audioOutputFormat = format;\r\n        }\r\n    }\r\n    private privAuthentication: IAuthentication;\r\n    private privConnectionFactory: ISynthesisConnectionFactory;\r\n\r\n    // A promise for a configured connection.\r\n    // Do not consume directly, call fetchConnection instead.\r\n    private privConnectionConfigurationPromise: Promise<IConnection> = undefined;\r\n\r\n    // A promise for a connection, but one that has not had the speech context sent yet.\r\n    // Do not consume directly, call fetchConnection instead.\r\n    private privConnectionPromise: Promise<IConnection>;\r\n    private privAuthFetchEventId: string;\r\n    private privIsDisposed: boolean;\r\n    private privConnectionEvents: EventSource<ConnectionEvent>;\r\n    private privServiceEvents: EventSource<ServiceEvent>;\r\n    private privSynthesisContext: SynthesisContext;\r\n    private privAgentConfig: AgentConfig;\r\n    private privActivityTemplate: string;\r\n    private privAudioOutputFormat: AudioOutputFormatImpl;\r\n    private privSessionAudioDestination: IAudioDestination;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: ISynthesisConnectionFactory,\r\n        synthesizerConfig: SynthesizerConfig,\r\n        speechSynthesizer: SpeechSynthesizer,\r\n        audioDestination: IAudioDestination) {\r\n\r\n        if (!authentication) {\r\n            throw new ArgumentNullError(\"authentication\");\r\n        }\r\n\r\n        if (!connectionFactory) {\r\n            throw new ArgumentNullError(\"connectionFactory\");\r\n        }\r\n\r\n        if (!synthesizerConfig) {\r\n            throw new ArgumentNullError(\"synthesizerConfig\");\r\n        }\r\n\r\n        this.privAuthentication = authentication;\r\n        this.privConnectionFactory = connectionFactory;\r\n        this.privSynthesizerConfig = synthesizerConfig;\r\n        this.privIsDisposed = false;\r\n        this.privSpeechSynthesizer = speechSynthesizer;\r\n        this.privSessionAudioDestination = audioDestination;\r\n        this.privSynthesisTurn = new SynthesisTurn();\r\n        this.privConnectionEvents = new EventSource<ConnectionEvent>();\r\n        this.privServiceEvents = new EventSource<ServiceEvent>();\r\n        this.privSynthesisContext = new SynthesisContext(this.privSpeechSynthesizer);\r\n        this.privAgentConfig = new AgentConfig();\r\n\r\n        this.connectionEvents.attach((connectionEvent: ConnectionEvent): void => {\r\n            if (connectionEvent.name === \"ConnectionClosedEvent\") {\r\n                const connectionClosedEvent = connectionEvent as ConnectionClosedEvent;\r\n                if (connectionClosedEvent.statusCode !== 1000) {\r\n                    this.cancelSynthesisLocal(CancellationReason.Error,\r\n                        connectionClosedEvent.statusCode === 1007 ? CancellationErrorCode.BadRequestParameters : CancellationErrorCode.ConnectionFailure,\r\n                        `${connectionClosedEvent.reason} websocket error code: ${connectionClosedEvent.statusCode}`);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    public static addHeader(audio: ArrayBuffer, format: AudioOutputFormatImpl): ArrayBuffer {\r\n        if (!format.hasHeader) {\r\n            return audio;\r\n        }\r\n        format.updateHeader(audio.byteLength);\r\n        const tmp = new Uint8Array(audio.byteLength + format.header.byteLength);\r\n        tmp.set(new Uint8Array(format.header), 0);\r\n        tmp.set(new Uint8Array(audio), format.header.byteLength);\r\n        return tmp.buffer;\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return this.privIsDisposed;\r\n    }\r\n\r\n    public async dispose(reason?: string): Promise<void> {\r\n        this.privIsDisposed = true;\r\n        if (this.privSessionAudioDestination !== undefined) {\r\n            this.privSessionAudioDestination.close();\r\n        }\r\n        if (this.privConnectionConfigurationPromise !== undefined) {\r\n            const connection: IConnection = await this.privConnectionConfigurationPromise;\r\n            await connection.dispose(reason);\r\n        }\r\n    }\r\n\r\n    public async connect(): Promise<void> {\r\n        await this.connectImpl();\r\n    }\r\n\r\n    public async sendNetworkMessage(path: string, payload: string | ArrayBuffer): Promise<void> {\r\n        const type: MessageType = typeof payload === \"string\" ? MessageType.Text : MessageType.Binary;\r\n        const contentType: string = typeof payload === \"string\" ? \"application/json\" : \"\";\r\n\r\n        const connection: IConnection = await this.fetchConnection();\r\n        return connection.send(new SpeechConnectionMessage(type, path, this.privSynthesisTurn.requestId, contentType, payload));\r\n    }\r\n\r\n    public async Speak(\r\n        text: string,\r\n        isSSML: boolean,\r\n        requestId: string,\r\n        successCallback: (e: SpeechSynthesisResult) => void,\r\n        errorCallBack: (e: string) => void,\r\n        audioDestination: IAudioDestination,\r\n    ): Promise<void> {\r\n\r\n        let ssml: string;\r\n\r\n        if (isSSML) {\r\n            ssml = text;\r\n        } else {\r\n            ssml = this.privSpeechSynthesizer.buildSsml(text);\r\n        }\r\n\r\n        if (this.speakOverride !== undefined) {\r\n            return this.speakOverride(ssml, requestId, successCallback, errorCallBack);\r\n        }\r\n\r\n        this.privSuccessCallback = successCallback;\r\n        this.privErrorCallback = errorCallBack;\r\n\r\n        this.privSynthesisTurn.startNewSynthesis(requestId, text, isSSML, audioDestination);\r\n\r\n        try {\r\n            await this.connectImpl();\r\n            const connection: IConnection = await this.fetchConnection();\r\n            await this.sendSynthesisContext(connection);\r\n            await this.sendSsmlMessage(connection, ssml, requestId);\r\n            const synthesisStartEventArgs: SpeechSynthesisEventArgs = new SpeechSynthesisEventArgs(\r\n                new SpeechSynthesisResult(\r\n                    requestId,\r\n                    ResultReason.SynthesizingAudioStarted,\r\n                )\r\n            );\r\n\r\n            if (!!this.privSpeechSynthesizer.synthesisStarted) {\r\n                this.privSpeechSynthesizer.synthesisStarted(this.privSpeechSynthesizer, synthesisStartEventArgs);\r\n            }\r\n\r\n            void this.receiveMessage();\r\n        } catch (e) {\r\n            this.cancelSynthesisLocal(CancellationReason.Error, CancellationErrorCode.ConnectionFailure, e as string);\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    // Cancels synthesis.\r\n    protected cancelSynthesis(\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n        const properties: PropertyCollection = new PropertyCollection();\r\n        properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\r\n        const result: SpeechSynthesisResult = new SpeechSynthesisResult(\r\n            requestId,\r\n            ResultReason.Canceled,\r\n            undefined,\r\n            error,\r\n            properties\r\n        );\r\n\r\n        if (!!this.privSpeechSynthesizer.SynthesisCanceled) {\r\n            const cancelEvent: SpeechSynthesisEventArgs = new SpeechSynthesisEventArgs(result);\r\n            try {\r\n                this.privSpeechSynthesizer.SynthesisCanceled(this.privSpeechSynthesizer, cancelEvent);\r\n                /* eslint-disable no-empty */\r\n            } catch { }\r\n        }\r\n\r\n        if (!!this.privSuccessCallback) {\r\n            try {\r\n                this.privSuccessCallback(result);\r\n                /* eslint-disable no-empty */\r\n            } catch { }\r\n        }\r\n    }\r\n\r\n    // Cancels synthesis.\r\n    protected cancelSynthesisLocal(\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n\r\n        if (!!this.privSynthesisTurn.isSynthesizing) {\r\n            this.privSynthesisTurn.onStopSynthesizing();\r\n\r\n            this.cancelSynthesis(\r\n                this.privSynthesisTurn.requestId,\r\n                cancellationReason,\r\n                errorCode,\r\n                error);\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected processTypeSpecificMessages(connectionMessage: SpeechConnectionMessage): boolean {\r\n        return true;\r\n    }\r\n\r\n    protected async receiveMessage(): Promise<void> {\r\n        try {\r\n            const connection: IConnection = await this.fetchConnection();\r\n            const message: ConnectionMessage = await connection.read();\r\n\r\n            if (this.receiveMessageOverride !== undefined) {\r\n                return this.receiveMessageOverride();\r\n            }\r\n            if (this.privIsDisposed) {\r\n                // We're done.\r\n                return;\r\n            }\r\n\r\n            // indicates we are draining the queue and it came with no message;\r\n            if (!message) {\r\n                if (!this.privSynthesisTurn.isSynthesizing) {\r\n                    return;\r\n                } else {\r\n                    return this.receiveMessage();\r\n                }\r\n            }\r\n\r\n\r\n            const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\r\n\r\n            if (connectionMessage.requestId.toLowerCase() === this.privSynthesisTurn.requestId.toLowerCase()) {\r\n                switch (connectionMessage.path.toLowerCase()) {\r\n                    case \"turn.start\":\r\n                        this.privSynthesisTurn.onServiceTurnStartResponse();\r\n                        break;\r\n                    case \"response\":\r\n                        this.privSynthesisTurn.onServiceResponseMessage(connectionMessage.textBody);\r\n                        break;\r\n                    case \"audio\":\r\n                        if (this.privSynthesisTurn.streamId.toLowerCase() === connectionMessage.streamId.toLowerCase()\r\n                            && !!connectionMessage.binaryBody) {\r\n                            this.privSynthesisTurn.onAudioChunkReceived(connectionMessage.binaryBody);\r\n                            if (!!this.privSpeechSynthesizer.synthesizing) {\r\n                                try {\r\n                                    const audioWithHeader = SynthesisAdapterBase.addHeader(connectionMessage.binaryBody, this.privSynthesisTurn.audioOutputFormat);\r\n                                    const ev: SpeechSynthesisEventArgs = new SpeechSynthesisEventArgs(\r\n                                        new SpeechSynthesisResult(\r\n                                            this.privSynthesisTurn.requestId,\r\n                                            ResultReason.SynthesizingAudio,\r\n                                            audioWithHeader));\r\n                                    this.privSpeechSynthesizer.synthesizing(this.privSpeechSynthesizer, ev);\r\n                                } catch (error) {\r\n                                    // Not going to let errors in the event handler\r\n                                    // trip things up.\r\n                                }\r\n                            }\r\n                            if (this.privSessionAudioDestination !== undefined) {\r\n                                this.privSessionAudioDestination.write(connectionMessage.binaryBody);\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \"audio.metadata\":\r\n                        const metadataList = SynthesisAudioMetadata.fromJSON(connectionMessage.textBody).Metadata;\r\n                        for (const metadata of metadataList) {\r\n                            switch (metadata.Type) {\r\n                                case MetadataType.WordBoundary:\r\n                                case MetadataType.SentenceBoundary:\r\n                                    this.privSynthesisTurn.onTextBoundaryEvent(metadata);\r\n\r\n                                    const wordBoundaryEventArgs: SpeechSynthesisWordBoundaryEventArgs = new SpeechSynthesisWordBoundaryEventArgs(\r\n                                        metadata.Data.Offset,\r\n                                        metadata.Data.Duration,\r\n                                        metadata.Data.text.Text,\r\n                                        metadata.Data.text.Length,\r\n                                        metadata.Type === MetadataType.WordBoundary\r\n                                            ? this.privSynthesisTurn.currentTextOffset : this.privSynthesisTurn.currentSentenceOffset,\r\n                                        metadata.Data.text.BoundaryType);\r\n\r\n                                    if (!!this.privSpeechSynthesizer.wordBoundary) {\r\n                                        try {\r\n                                            this.privSpeechSynthesizer.wordBoundary(this.privSpeechSynthesizer, wordBoundaryEventArgs);\r\n                                        } catch (error) {\r\n                                            // Not going to let errors in the event handler\r\n                                            // trip things up.\r\n                                        }\r\n                                    }\r\n                                    break;\r\n                                case MetadataType.Bookmark:\r\n                                    const bookmarkEventArgs: SpeechSynthesisBookmarkEventArgs = new SpeechSynthesisBookmarkEventArgs(\r\n                                        metadata.Data.Offset,\r\n                                        metadata.Data.Bookmark);\r\n\r\n                                    if (!!this.privSpeechSynthesizer.bookmarkReached) {\r\n                                        try {\r\n                                            this.privSpeechSynthesizer.bookmarkReached(this.privSpeechSynthesizer, bookmarkEventArgs);\r\n                                        } catch (error) {\r\n                                            // Not going to let errors in the event handler\r\n                                            // trip things up.\r\n                                        }\r\n                                    }\r\n                                    break;\r\n                                case MetadataType.Viseme:\r\n                                    this.privSynthesisTurn.onVisemeMetadataReceived(metadata);\r\n                                    if (metadata.Data.IsLastAnimation) {\r\n                                        const visemeEventArgs: SpeechSynthesisVisemeEventArgs = new SpeechSynthesisVisemeEventArgs(\r\n                                            metadata.Data.Offset,\r\n                                            metadata.Data.VisemeId,\r\n                                            this.privSynthesisTurn.getAndClearVisemeAnimation());\r\n\r\n                                        if (!!this.privSpeechSynthesizer.visemeReceived) {\r\n                                            try {\r\n                                                this.privSpeechSynthesizer.visemeReceived(this.privSpeechSynthesizer, visemeEventArgs);\r\n                                            } catch (error) {\r\n                                                // Not going to let errors in the event handler\r\n                                                // trip things up.\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    break;\r\n                                case MetadataType.SessionEnd:\r\n                                    this.privSynthesisTurn.onSessionEnd(metadata);\r\n                                    break;\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \"turn.end\":\r\n                        this.privSynthesisTurn.onServiceTurnEndResponse();\r\n                        let result: SpeechSynthesisResult;\r\n                        try {\r\n                            const audioBuffer: ArrayBuffer = await this.privSynthesisTurn.getAllReceivedAudioWithHeader();\r\n                            result = new SpeechSynthesisResult(\r\n                                this.privSynthesisTurn.requestId,\r\n                                ResultReason.SynthesizingAudioCompleted,\r\n                                audioBuffer,\r\n                                undefined,\r\n                                undefined,\r\n                                this.privSynthesisTurn.audioDuration\r\n                            );\r\n                            if (!!this.privSuccessCallback) {\r\n                                this.privSuccessCallback(result);\r\n                            }\r\n                        } catch (error) {\r\n                            if (!!this.privErrorCallback) {\r\n                                this.privErrorCallback(error as string);\r\n                            }\r\n                        }\r\n                        if (this.privSpeechSynthesizer.synthesisCompleted) {\r\n                            try {\r\n                                this.privSpeechSynthesizer.synthesisCompleted(\r\n                                    this.privSpeechSynthesizer,\r\n                                    new SpeechSynthesisEventArgs(result)\r\n                                );\r\n                            } catch (e) {\r\n                                // Not going to let errors in the event handler\r\n                                // trip things up.\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    default:\r\n\r\n                        if (!this.processTypeSpecificMessages(connectionMessage)) {\r\n                            // here are some messages that the derived class has not processed, dispatch them to connect class\r\n                            if (!!this.privServiceEvents) {\r\n                                this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\r\n                            }\r\n                        }\r\n\r\n                }\r\n            }\r\n\r\n            return this.receiveMessage();\r\n\r\n        } catch (e) {\r\n            // TODO: What goes here?\r\n        }\r\n    }\r\n\r\n    protected sendSynthesisContext(connection: IConnection): Promise<void> {\r\n        const synthesisContextJson = this.synthesisContext.toJSON();\r\n\r\n        if (synthesisContextJson) {\r\n            return connection.send(new SpeechConnectionMessage(\r\n                MessageType.Text,\r\n                \"synthesis.context\",\r\n                this.privSynthesisTurn.requestId,\r\n                \"application/json\",\r\n                synthesisContextJson));\r\n        }\r\n        return;\r\n    }\r\n\r\n    protected connectImpl(isUnAuthorized: boolean = false): Promise<IConnection> {\r\n        if (this.privConnectionPromise != null) {\r\n            return this.privConnectionPromise.then((connection: IConnection): Promise<IConnection> => {\r\n                if (connection.state() === ConnectionState.Disconnected) {\r\n                    this.privConnectionId = null;\r\n                    this.privConnectionPromise = null;\r\n                    return this.connectImpl();\r\n                }\r\n                return this.privConnectionPromise;\r\n            }, (): Promise<IConnection> => {\r\n                this.privConnectionId = null;\r\n                this.privConnectionPromise = null;\r\n                return this.connectImpl();\r\n            });\r\n        }\r\n        this.privAuthFetchEventId = createNoDashGuid();\r\n        this.privConnectionId = createNoDashGuid();\r\n\r\n        this.privSynthesisTurn.onPreConnectionStart(this.privAuthFetchEventId);\r\n\r\n        const authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);\r\n\r\n        this.privConnectionPromise = authPromise.then(async (result: AuthInfo): Promise<IConnection> => {\r\n            this.privSynthesisTurn.onAuthCompleted(false);\r\n\r\n            const connection: IConnection = this.privConnectionFactory.create(this.privSynthesizerConfig, result, this.privConnectionId);\r\n\r\n            // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\r\n            // it'll stop sending events.\r\n            connection.events.attach((event: ConnectionEvent): void => {\r\n                this.connectionEvents.onEvent(event);\r\n            });\r\n            const response = await connection.open();\r\n            if (response.statusCode === 200) {\r\n                this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);\r\n                return Promise.resolve(connection);\r\n            } else if (response.statusCode === 403 && !isUnAuthorized) {\r\n                return this.connectImpl(true);\r\n            } else {\r\n                this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);\r\n                return Promise.reject(`Unable to contact server. StatusCode: ${response.statusCode}, ${this.privSynthesizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${response.reason}`);\r\n            }\r\n        }, (error: string): Promise<IConnection> => {\r\n            this.privSynthesisTurn.onAuthCompleted(true);\r\n            throw new Error(error);\r\n        });\r\n\r\n        // Attach an empty handler to allow the promise to run in the background while\r\n        // other startup events happen. It'll eventually be awaited on.\r\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n        this.privConnectionPromise.catch((): void => { });\r\n\r\n        return this.privConnectionPromise;\r\n    }\r\n    protected sendSpeechServiceConfig(connection: IConnection, SpeechServiceConfigJson: string): Promise<void> {\r\n        if (SpeechServiceConfigJson) {\r\n            return connection.send(new SpeechConnectionMessage(\r\n                MessageType.Text,\r\n                \"speech.config\",\r\n                this.privSynthesisTurn.requestId,\r\n                \"application/json\",\r\n                SpeechServiceConfigJson));\r\n        }\r\n    }\r\n\r\n    protected sendSsmlMessage(connection: IConnection, ssml: string, requestId: string): Promise<void> {\r\n        return connection.send(new SpeechConnectionMessage(\r\n            MessageType.Text,\r\n            \"ssml\",\r\n            requestId,\r\n            \"application/ssml+xml\",\r\n            ssml));\r\n    }\r\n\r\n    private async fetchConnection(): Promise<IConnection> {\r\n        if (this.privConnectionConfigurationPromise !== undefined) {\r\n            return this.privConnectionConfigurationPromise.then((connection: IConnection): Promise<IConnection> => {\r\n                if (connection.state() === ConnectionState.Disconnected) {\r\n                    this.privConnectionId = null;\r\n                    this.privConnectionConfigurationPromise = undefined;\r\n                    return this.fetchConnection();\r\n                }\r\n                return this.privConnectionConfigurationPromise;\r\n            }, (): Promise<IConnection> => {\r\n                this.privConnectionId = null;\r\n                this.privConnectionConfigurationPromise = undefined;\r\n                return this.fetchConnection();\r\n            });\r\n        }\r\n        this.privConnectionConfigurationPromise = this.configureConnection();\r\n        return await this.privConnectionConfigurationPromise;\r\n    }\r\n\r\n    // Takes an established websocket connection to the endpoint and sends speech configuration information.\r\n    private async configureConnection(): Promise<IConnection> {\r\n        const connection: IConnection = await this.connectImpl();\r\n        if (this.configConnectionOverride !== undefined) {\r\n            return this.configConnectionOverride(connection);\r\n        }\r\n        await this.sendSpeechServiceConfig(connection, this.privSynthesizerConfig.SpeechServiceConfig.serialize());\r\n        return connection;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}