{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ConnectionState, createNoDashGuid, Deferred, MessageType } from \"../../common/Exports\";\nimport { CancellationErrorCode, CancellationReason, ConversationExpirationEventArgs, ConversationTranslationCanceledEventArgs, ConversationTranslationResult, Translations } from \"../../sdk/Exports\";\nimport { CognitiveTokenAuthentication, ServiceRecognizerBase } from \"../Exports\";\nimport { ConversationConnectionMessage } from \"./ConversationConnectionMessage\";\nimport { ConversationRequestSession } from \"./ConversationRequestSession\";\nimport { ConversationReceivedTranslationEventArgs, LockRoomEventArgs, MuteAllEventArgs, ParticipantAttributeEventArgs, ParticipantEventArgs, ParticipantsListEventArgs } from \"./ConversationTranslatorEventArgs\";\nimport { ConversationTranslatorCommandTypes, ConversationTranslatorMessageTypes } from \"./ConversationTranslatorInterfaces\";\nimport { CommandResponsePayload, ParticipantPayloadResponse, ParticipantsListPayloadResponse, SpeechResponsePayload, TextResponsePayload } from \"./ServiceMessages/Exports\";\n/**\n * The service adapter handles sending and receiving messages to the Conversation Translator websocket.\n */\n\nexport class ConversationServiceAdapter extends ServiceRecognizerBase {\n  constructor(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector) {\n    super(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector);\n    this.privConnectionConfigPromise = undefined;\n    this.privLastPartialUtteranceId = \"\";\n    this.privConversationServiceConnector = conversationServiceConnector;\n    this.privConversationAuthentication = authentication;\n\n    this.receiveMessageOverride = () => this.receiveConversationMessageOverride();\n\n    this.recognizeOverride = () => this.noOp();\n\n    this.postConnectImplOverride = connection => this.conversationConnectImpl(connection);\n\n    this.configConnectionOverride = () => this.configConnection();\n\n    this.disconnectOverride = () => this.privDisconnect();\n\n    this.privConversationRequestSession = new ConversationRequestSession(createNoDashGuid());\n    this.privConversationConnectionFactory = connectionFactory;\n    this.privConversationIsDisposed = false;\n  }\n\n  isDisposed() {\n    return super.isDisposed() || this.privConversationIsDisposed;\n  }\n\n  dispose(reason) {\n    const _super = Object.create(null, {\n      dispose: {\n        get: () => super.dispose\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privConversationIsDisposed = true;\n\n      if (this.privConnectionConfigPromise !== undefined) {\n        const connection = yield this.privConnectionConfigPromise;\n        yield connection.dispose(reason);\n      }\n\n      yield _super.dispose.call(this, reason);\n    });\n  }\n\n  sendMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.fetchConnection();\n      return connection.send(new ConversationConnectionMessage(MessageType.Text, message));\n    });\n  }\n\n  sendMessageAsync(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.fetchConnection();\n      yield connection.send(new ConversationConnectionMessage(MessageType.Text, message));\n    });\n  }\n\n  privDisconnect() {\n    if (this.terminateMessageLoop) {\n      return;\n    }\n\n    this.cancelRecognition(this.privConversationRequestSession.sessionId, this.privConversationRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.NoError, \"Disconnecting\");\n    this.terminateMessageLoop = true;\n    return Promise.resolve();\n  } // eslint-disable-next-line @typescript-eslint/require-await\n\n\n  processTypeSpecificMessages() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return true;\n    });\n  } // Cancels recognition.\n\n\n  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n    this.terminateMessageLoop = true;\n    const cancelEvent = new ConversationTranslationCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);\n\n    try {\n      if (!!this.privConversationServiceConnector.canceled) {\n        this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, cancelEvent);\n      }\n    } catch (_a) {// continue on error\n    }\n  }\n\n  noOp() {\n    // operation not supported\n    return;\n  }\n  /**\n   * Establishes a websocket connection to the end point.\n   */\n\n\n  conversationConnectImpl(connection) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privConnectionLoop = this.startMessageLoop();\n      return connection;\n    });\n  }\n  /**\n   * Process incoming websocket messages\n   */\n\n\n  receiveConversationMessageOverride() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.isDisposed() || this.terminateMessageLoop) {\n        return Promise.resolve();\n      } // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\n\n\n      const communicationCustodian = new Deferred();\n\n      try {\n        const connection = yield this.fetchConnection();\n        const message = yield connection.read();\n\n        if (this.isDisposed() || this.terminateMessageLoop) {\n          // We're done.\n          communicationCustodian.resolve();\n          return Promise.resolve();\n        }\n\n        if (!message) {\n          return this.receiveConversationMessageOverride();\n        }\n\n        const sessionId = this.privConversationRequestSession.sessionId;\n        let sendFinal = false;\n\n        try {\n          switch (message.conversationMessageType.toLowerCase()) {\n            case \"info\":\n            case \"participant_command\":\n            case \"command\":\n              const commandPayload = CommandResponsePayload.fromJSON(message.textBody);\n\n              switch (commandPayload.command.toLowerCase()) {\n                /**\n                 * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.\n                 * The consuming client must wait for this message to arrive\n                 * before starting to send their own data.\n                 */\n                case \"participantlist\":\n                  const participantsPayload = ParticipantsListPayloadResponse.fromJSON(message.textBody);\n                  const participantsResult = participantsPayload.participants.map(p => {\n                    const participant = {\n                      avatar: p.avatar,\n                      displayName: p.nickname,\n                      id: p.participantId,\n                      isHost: p.ishost,\n                      isMuted: p.ismuted,\n                      isUsingTts: p.usetts,\n                      preferredLanguage: p.locale\n                    };\n                    return participant;\n                  });\n\n                  if (!!this.privConversationServiceConnector.participantsListReceived) {\n                    this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector, new ParticipantsListEventArgs(participantsPayload.roomid, participantsPayload.token, participantsPayload.translateTo, participantsPayload.profanityFilter, participantsPayload.roomProfanityFilter, participantsPayload.roomLocked, participantsPayload.muteAll, participantsResult, sessionId));\n                  }\n\n                  break;\n\n                /**\n                 * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).\n                 * This is sent at the start of the Conversation\n                 */\n\n                case \"settranslatetolanguages\":\n                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setTranslateToLanguages, commandPayload.value, sessionId));\n                  }\n\n                  break;\n\n                /**\n                 * 'SetProfanityFiltering' lets the client set the level of profanity filtering.\n                 * If sent by the participant the setting will effect only their own profanity level.\n                 * If sent by the host, the setting will effect all participants including the host.\n                 * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'\n                 */\n\n                case \"setprofanityfiltering\":\n                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setProfanityFiltering, commandPayload.value, sessionId));\n                  }\n\n                  break;\n\n                /**\n                 * 'SetMute' is sent if the participant has been muted by the host.\n                 * Check the 'participantId' to determine if the current user has been muted.\n                 */\n\n                case \"setmute\":\n                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setMute, commandPayload.value, sessionId));\n                  }\n\n                  break;\n\n                /**\n                 * 'SetMuteAll' is sent if the Conversation has been muted by the host.\n                 */\n\n                case \"setmuteall\":\n                  if (!!this.privConversationServiceConnector.muteAllCommandReceived) {\n                    this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector, new MuteAllEventArgs(commandPayload.value, sessionId));\n                  }\n\n                  break;\n\n                /**\n                 * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.\n                 */\n\n                case \"roomexpirationwarning\":\n                  if (!!this.privConversationServiceConnector.conversationExpiration) {\n                    this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector, new ConversationExpirationEventArgs(commandPayload.value, this.privConversationRequestSession.sessionId));\n                  }\n\n                  break;\n\n                /**\n                 * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.\n                 */\n\n                case \"setusetts\":\n                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setUseTTS, commandPayload.value, sessionId));\n                  }\n\n                  break;\n\n                /**\n                 * 'SetLockState' is set if the host has locked or unlocked the Conversation.\n                 */\n\n                case \"setlockstate\":\n                  if (!!this.privConversationServiceConnector.lockRoomCommandReceived) {\n                    this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector, new LockRoomEventArgs(commandPayload.value, sessionId));\n                  }\n\n                  break;\n\n                /**\n                 * 'ChangeNickname' is received if a user changes their display name.\n                 * Any cached particpiants list should be updated to reflect the display name.\n                 */\n\n                case \"changenickname\":\n                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.changeNickname, commandPayload.nickname, sessionId));\n                  }\n\n                  break;\n\n                /**\n                 * 'JoinSession' is sent when a user joins the Conversation.\n                 */\n\n                case \"joinsession\":\n                  const joinParticipantPayload = ParticipantPayloadResponse.fromJSON(message.textBody);\n                  const joiningParticipant = {\n                    avatar: joinParticipantPayload.avatar,\n                    displayName: joinParticipantPayload.nickname,\n                    id: joinParticipantPayload.participantId,\n                    isHost: joinParticipantPayload.ishost,\n                    isMuted: joinParticipantPayload.ismuted,\n                    isUsingTts: joinParticipantPayload.usetts,\n                    preferredLanguage: joinParticipantPayload.locale\n                  };\n\n                  if (!!this.privConversationServiceConnector.participantJoinCommandReceived) {\n                    this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector, new ParticipantEventArgs(joiningParticipant, sessionId));\n                  }\n\n                  break;\n\n                /**\n                 * 'LeaveSession' is sent when a user leaves the Conversation'.\n                 */\n\n                case \"leavesession\":\n                  const leavingParticipant = {\n                    id: commandPayload.participantId\n                  };\n\n                  if (!!this.privConversationServiceConnector.participantLeaveCommandReceived) {\n                    this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector, new ParticipantEventArgs(leavingParticipant, sessionId));\n                  }\n\n                  break;\n\n                /**\n                 * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).\n                 * Check the 'ParticipantId' to check whether the message is for the current user.\n                 */\n\n                case \"disconnectsession\":\n                  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                  const disconnectParticipant = {\n                    id: commandPayload.participantId\n                  };\n                  break;\n\n                case \"token\":\n                  const token = new CognitiveTokenAuthentication(() => {\n                    const authorizationToken = commandPayload.token;\n                    return Promise.resolve(authorizationToken);\n                  }, () => {\n                    const authorizationToken = commandPayload.token;\n                    return Promise.resolve(authorizationToken);\n                  });\n                  this.authentication = token;\n                  break;\n\n                /**\n                 * Message not recognized.\n                 */\n\n                default:\n                  break;\n              }\n\n              break;\n\n            /**\n             * 'partial' (or 'hypothesis') represents a unfinalized speech message.\n             */\n\n            case \"partial\":\n            /**\n             * 'final' (or 'phrase') represents a finalized speech message.\n             */\n\n            case \"final\":\n              const speechPayload = SpeechResponsePayload.fromJSON(message.textBody);\n              const speechResult = new ConversationTranslationResult(speechPayload.participantId, this.getTranslations(speechPayload.translations), speechPayload.language, undefined, undefined, speechPayload.recognition, undefined, undefined, message.textBody, undefined);\n\n              if (speechPayload.isFinal) {\n                // check the length, sometimes empty finals are returned\n                if (speechResult.text !== undefined && speechResult.text.length > 0) {\n                  sendFinal = true;\n                } else if (speechPayload.id === this.privLastPartialUtteranceId) {\n                  // send final as normal. We had a non-empty partial for this same utterance\n                  // so sending the empty final is important\n                  sendFinal = true;\n                } else {// suppress unneeded final\n                }\n\n                if (sendFinal) {\n                  if (!!this.privConversationServiceConnector.translationReceived) {\n                    this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.final, speechResult, sessionId));\n                  }\n                }\n              } else if (speechResult.text !== undefined) {\n                this.privLastPartialUtteranceId = speechPayload.id;\n\n                if (!!this.privConversationServiceConnector.translationReceived) {\n                  this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.partial, speechResult, sessionId));\n                }\n              }\n\n              break;\n\n            /**\n             * \"translated_message\" is a text message or instant message (IM).\n             */\n\n            case \"translated_message\":\n              const textPayload = TextResponsePayload.fromJSON(message.textBody);\n              const textResult = new ConversationTranslationResult(textPayload.participantId, this.getTranslations(textPayload.translations), textPayload.language, undefined, undefined, textPayload.originalText, undefined, undefined, undefined, message.textBody, undefined);\n\n              if (!!this.privConversationServiceConnector.translationReceived) {\n                this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.instantMessage, textResult, sessionId));\n              }\n\n              break;\n\n            default:\n              // ignore any unsupported message types\n              break;\n          }\n        } catch (e) {// continue\n        }\n\n        return this.receiveConversationMessageOverride();\n      } catch (e) {\n        this.terminateMessageLoop = true;\n      }\n\n      return communicationCustodian.promise;\n    });\n  }\n\n  startMessageLoop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.isDisposed()) {\n        return Promise.resolve();\n      }\n\n      this.terminateMessageLoop = false;\n      const messageRetrievalPromise = this.receiveConversationMessageOverride();\n\n      try {\n        const r = yield messageRetrievalPromise;\n        return r;\n      } catch (error) {\n        this.cancelRecognition(this.privRequestSession ? this.privRequestSession.sessionId : \"\", this.privRequestSession ? this.privRequestSession.requestId : \"\", CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\n        return null;\n      }\n    });\n  } // Takes an established websocket connection to the endpoint\n\n\n  configConnection() {\n    if (this.isDisposed()) {\n      return Promise.resolve(undefined);\n    }\n\n    if (this.privConnectionConfigPromise !== undefined) {\n      return this.privConnectionConfigPromise.then(connection => {\n        if (connection.state() === ConnectionState.Disconnected) {\n          this.privConnectionId = null;\n          this.privConnectionConfigPromise = undefined;\n          return this.configConnection();\n        }\n\n        return this.privConnectionConfigPromise;\n      }, () => {\n        this.privConnectionId = null;\n        this.privConnectionConfigPromise = undefined;\n        return this.configConnection();\n      });\n    }\n\n    if (this.terminateMessageLoop) {\n      return Promise.resolve(undefined);\n    }\n\n    this.privConnectionConfigPromise = this.connectImpl().then(connection => connection);\n    return this.privConnectionConfigPromise;\n  }\n\n  getTranslations(serviceResultTranslations) {\n    let translations;\n\n    if (undefined !== serviceResultTranslations) {\n      translations = new Translations();\n\n      for (const translation of serviceResultTranslations) {\n        translations.set(translation.lang, translation.translation);\n      }\n    }\n\n    return translations;\n  }\n\n}","map":{"version":3,"sources":["src/common.speech/Transcription/ConversationServiceAdapter.ts"],"names":[],"mappings":"AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,SACI,eADJ,EAEI,gBAFJ,EAGI,QAHJ,EAMI,WANJ,QAOO,sBAPP;AAQA,SACI,qBADJ,EAEI,kBAFJ,EAGI,+BAHJ,EAII,wCAJJ,EAKI,6BALJ,EAMI,YANJ,QAOO,mBAPP;AAQA,SACI,4BADJ,EAKI,qBALJ,QAMO,YANP;AAOA,SAAS,6BAAT,QAA8C,iCAA9C;AACA,SAAS,0BAAT,QAA2C,8BAA3C;AACA,SACI,wCADJ,EAEI,iBAFJ,EAGI,gBAHJ,EAII,6BAJJ,EAKI,oBALJ,EAMI,yBANJ,QAOO,mCAPP;AAQA,SACI,kCADJ,EAEI,kCAFJ,QAIO,oCAJP;AAMA,SACI,sBADJ,EAKI,0BALJ,EAMI,+BANJ,EAOI,qBAPJ,EAQI,mBARJ,QASO,2BATP;AAWA;;AAEG;;AACH,OAAM,MAAO,0BAAP,SAA0C,qBAA1C,CAA+D;AAYjE,EAAA,WAAA,CACI,cADJ,EAEI,iBAFJ,EAGI,WAHJ,EAII,gBAJJ,EAKI,4BALJ,EAKkE;AAE9D,UAAM,cAAN,EAAsB,iBAAtB,EAAyC,WAAzC,EAAsD,gBAAtD,EAAwE,4BAAxE;AAbI,SAAA,2BAAA,GAAoD,SAApD;AAeJ,SAAK,0BAAL,GAAkC,EAAlC;AACA,SAAK,gCAAL,GAAwC,4BAAxC;AACA,SAAK,8BAAL,GAAsC,cAAtC;;AACA,SAAK,sBAAL,GAA8B,MAAqB,KAAK,kCAAL,EAAnD;;AACA,SAAK,iBAAL,GAAyB,MAAqB,KAAK,IAAL,EAA9C;;AACA,SAAK,uBAAL,GAAgC,UAAD,IAA4D,KAAK,uBAAL,CAA6B,UAA7B,CAA3F;;AACA,SAAK,wBAAL,GAAgC,MAA4B,KAAK,gBAAL,EAA5D;;AACA,SAAK,kBAAL,GAA0B,MAAqB,KAAK,cAAL,EAA/C;;AACA,SAAK,8BAAL,GAAsC,IAAI,0BAAJ,CAA+B,gBAAgB,EAA/C,CAAtC;AACA,SAAK,iCAAL,GAAyC,iBAAzC;AACA,SAAK,0BAAL,GAAkC,KAAlC;AACH;;AAEM,EAAA,UAAU,GAAA;AACb,WAAO,MAAM,UAAN,MAAsB,KAAK,0BAAlC;AACH;;AAEY,EAAA,OAAO,CAAC,MAAD,EAAgB;;;;;;;;AAChC,WAAK,0BAAL,GAAkC,IAAlC;;AACA,UAAI,KAAK,2BAAL,KAAqC,SAAzC,EAAoD;AAChD,cAAM,UAAU,GAAgB,MAAM,KAAK,2BAA3C;AACA,cAAM,UAAU,CAAC,OAAX,CAAmB,MAAnB,CAAN;AACH;;AACD,YAAM,MAAA,CAAM,OAAN,CAAa,IAAb,CAAa,IAAb,EAAc,MAAd,CAAN;AACH,K;AAAA;;AAEY,EAAA,WAAW,CAAC,OAAD,EAAgB;;AACpC,YAAM,UAAU,GAAgB,MAAM,KAAK,eAAL,EAAtC;AACA,aAAO,UAAU,CAAC,IAAX,CAAgB,IAAI,6BAAJ,CACnB,WAAW,CAAC,IADO,EAEnB,OAFmB,CAAhB,CAAP;AAGH,K;AAAA;;AAEY,EAAA,gBAAgB,CAAC,OAAD,EAAgB;;AACzC,YAAM,UAAU,GAAgB,MAAM,KAAK,eAAL,EAAtC;AAEA,YAAM,UAAU,CAAC,IAAX,CAAgB,IAAI,6BAAJ,CAAkC,WAAW,CAAC,IAA9C,EAAoD,OAApD,CAAhB,CAAN;AACH,K;AAAA;;AAES,EAAA,cAAc,GAAA;AACpB,QAAI,KAAK,oBAAT,EAA+B;AAC3B;AACH;;AACD,SAAK,iBAAL,CAAuB,KAAK,8BAAL,CAAoC,SAA3D,EACI,KAAK,8BAAL,CAAoC,SADxC,EAEI,kBAAkB,CAAC,KAFvB,EAGI,qBAAqB,CAAC,OAH1B,EAII,eAJJ;AAMA,SAAK,oBAAL,GAA4B,IAA5B;AACA,WAAO,OAAO,CAAC,OAAR,EAAP;AACH,GAxEgE,CA0EjE;;;AACgB,EAAA,2BAA2B,GAAA;;AACvC,aAAO,IAAP;AACH,K;AAAA,GA7EgE,CA+EjE;;;AACU,EAAA,iBAAiB,CACvB,SADuB,EAEvB,SAFuB,EAGvB,kBAHuB,EAIvB,SAJuB,EAKvB,KALuB,EAKV;AAEb,SAAK,oBAAL,GAA4B,IAA5B;AAEA,UAAM,WAAW,GAA6C,IAAI,wCAAJ,CAC1D,kBAD0D,EAE1D,KAF0D,EAG1D,SAH0D,EAI1D,SAJ0D,EAK1D,SAL0D,CAA9D;;AAOA,QAAI;AACA,UAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,QAA5C,EAAsD;AAClD,aAAK,gCAAL,CAAsC,QAAtC,CAA+C,KAAK,gCAApD,EAAsF,WAAtF;AACH;AACJ,KAJD,CAIE,OAAA,EAAA,EAAM,CACJ;AACH;AACJ;;AAES,EAAA,IAAI,GAAA;AACV;AACA;AACH;AAED;;AAEG;;;AACa,EAAA,uBAAuB,CAAC,UAAD,EAAiC;;AACpE,WAAK,kBAAL,GAA0B,KAAK,gBAAL,EAA1B;AACA,aAAO,UAAP;AACH,K;AAAA;AAED;;AAEG;;;AACW,EAAA,kCAAkC,GAAA;;AAC5C,UAAI,KAAK,UAAL,MAAqB,KAAK,oBAA9B,EAAoD;AAChD,eAAO,OAAO,CAAC,OAAR,EAAP;AACH,O,CACD;;;AACA,YAAM,sBAAsB,GAAmB,IAAI,QAAJ,EAA/C;;AAEA,UAAI;AACA,cAAM,UAAU,GAAgB,MAAM,KAAK,eAAL,EAAtC;AACA,cAAM,OAAO,GAAkC,MAAM,UAAU,CAAC,IAAX,EAArD;;AACA,YAAI,KAAK,UAAL,MAAqB,KAAK,oBAA9B,EAAoD;AAChD;AACA,UAAA,sBAAsB,CAAC,OAAvB;AACA,iBAAO,OAAO,CAAC,OAAR,EAAP;AACH;;AAED,YAAI,CAAC,OAAL,EAAc;AACV,iBAAO,KAAK,kCAAL,EAAP;AACH;;AAED,cAAM,SAAS,GAAW,KAAK,8BAAL,CAAoC,SAA9D;AACA,YAAI,SAAS,GAAY,KAAzB;;AAEA,YAAI;AACA,kBAAQ,OAAO,CAAC,uBAAR,CAAgC,WAAhC,EAAR;AACI,iBAAK,MAAL;AACA,iBAAK,qBAAL;AACA,iBAAK,SAAL;AACI,oBAAM,cAAc,GAA2B,sBAAsB,CAAC,QAAvB,CAAgC,OAAO,CAAC,QAAxC,CAA/C;;AACA,sBAAQ,cAAc,CAAC,OAAf,CAAuB,WAAvB,EAAR;AAEI;;;;AAIG;AACH,qBAAK,iBAAL;AAEI,wBAAM,mBAAmB,GAAqC,+BAA+B,CAAC,QAAhC,CAAyC,OAAO,CAAC,QAAjD,CAA9D;AAEA,wBAAM,kBAAkB,GAA2B,mBAAmB,CAAC,YAApB,CAAiC,GAAjC,CAAsC,CAAD,IAAyD;AAC7I,0BAAM,WAAW,GAAyB;AACtC,sBAAA,MAAM,EAAE,CAAC,CAAC,MAD4B;AAEtC,sBAAA,WAAW,EAAE,CAAC,CAAC,QAFuB;AAGtC,sBAAA,EAAE,EAAE,CAAC,CAAC,aAHgC;AAItC,sBAAA,MAAM,EAAE,CAAC,CAAC,MAJ4B;AAKtC,sBAAA,OAAO,EAAE,CAAC,CAAC,OAL2B;AAMtC,sBAAA,UAAU,EAAE,CAAC,CAAC,MANwB;AAOtC,sBAAA,iBAAiB,EAAE,CAAC,CAAC;AAPiB,qBAA1C;AASA,2BAAO,WAAP;AACH,mBAXkD,CAAnD;;AAaA,sBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,wBAA5C,EAAsE;AAClE,yBAAK,gCAAL,CAAsC,wBAAtC,CAA+D,KAAK,gCAApE,EACI,IAAI,yBAAJ,CAA8B,mBAAmB,CAAC,MAAlD,EAA0D,mBAAmB,CAAC,KAA9E,EACI,mBAAmB,CAAC,WADxB,EACqC,mBAAmB,CAAC,eADzD,EAEI,mBAAmB,CAAC,mBAFxB,EAE6C,mBAAmB,CAAC,UAFjE,EAGI,mBAAmB,CAAC,OAHxB,EAGiC,kBAHjC,EAGqD,SAHrD,CADJ;AAKH;;AACD;;AAEJ;;;AAGG;;AACH,qBAAK,yBAAL;AAEI,sBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,gCAA5C,EAA8E;AAC1E,yBAAK,gCAAL,CAAsC,gCAAtC,CAAuE,KAAK,gCAA5E,EACI,IAAI,6BAAJ,CAAkC,cAAc,CAAC,aAAjD,EACI,kCAAkC,CAAC,uBADvC,EAEI,cAAc,CAAC,KAFnB,EAE0B,SAF1B,CADJ;AAIH;;AAED;;AAEJ;;;;;AAKG;;AACH,qBAAK,uBAAL;AAEI,sBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,gCAA5C,EAA8E;AAC1E,yBAAK,gCAAL,CAAsC,gCAAtC,CAAuE,KAAK,gCAA5E,EACI,IAAI,6BAAJ,CAAkC,cAAc,CAAC,aAAjD,EACI,kCAAkC,CAAC,qBADvC,EAEI,cAAc,CAAC,KAFnB,EAE0B,SAF1B,CADJ;AAIH;;AAED;;AAEJ;;;AAGG;;AACH,qBAAK,SAAL;AAEI,sBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,gCAA5C,EAA8E;AAC1E,yBAAK,gCAAL,CAAsC,gCAAtC,CAAuE,KAAK,gCAA5E,EACI,IAAI,6BAAJ,CAAkC,cAAc,CAAC,aAAjD,EACI,kCAAkC,CAAC,OADvC,EAEI,cAAc,CAAC,KAFnB,EAE0B,SAF1B,CADJ;AAIH;;AAED;;AAEJ;;AAEG;;AACH,qBAAK,YAAL;AAEI,sBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,sBAA5C,EAAoE;AAChE,yBAAK,gCAAL,CAAsC,sBAAtC,CAA6D,KAAK,gCAAlE,EACI,IAAI,gBAAJ,CAAqB,cAAc,CAAC,KAApC,EAAsD,SAAtD,CADJ;AAEH;;AAED;;AAEJ;;AAEG;;AACH,qBAAK,uBAAL;AAEI,sBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,sBAA5C,EAAoE;AAChE,yBAAK,gCAAL,CAAsC,sBAAtC,CAA6D,KAAK,gCAAlE,EACI,IAAI,+BAAJ,CAAoC,cAAc,CAAC,KAAnD,EAAoE,KAAK,8BAAL,CAAoC,SAAxG,CADJ;AAEH;;AAED;;AAEJ;;AAEG;;AACH,qBAAK,WAAL;AAEI,sBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,gCAA5C,EAA8E;AAC1E,yBAAK,gCAAL,CAAsC,gCAAtC,CAAuE,KAAK,gCAA5E,EACI,IAAI,6BAAJ,CAAkC,cAAc,CAAC,aAAjD,EACI,kCAAkC,CAAC,SADvC,EAEI,cAAc,CAAC,KAFnB,EAE0B,SAF1B,CADJ;AAIH;;AAED;;AAEJ;;AAEG;;AACH,qBAAK,cAAL;AAEI,sBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,uBAA5C,EAAqE;AACjE,yBAAK,gCAAL,CAAsC,uBAAtC,CAA8D,KAAK,gCAAnE,EACI,IAAI,iBAAJ,CAAsB,cAAc,CAAC,KAArC,EAAuD,SAAvD,CADJ;AAEH;;AAED;;AAEJ;;;AAGG;;AACH,qBAAK,gBAAL;AAEI,sBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,gCAA5C,EAA8E;AAC1E,yBAAK,gCAAL,CAAsC,gCAAtC,CAAuE,KAAK,gCAA5E,EACI,IAAI,6BAAJ,CAAkC,cAAc,CAAC,aAAjD,EACI,kCAAkC,CAAC,cADvC,EAEI,cAAc,CAAC,QAFnB,EAE6B,SAF7B,CADJ;AAIH;;AAED;;AAEJ;;AAEG;;AACH,qBAAK,aAAL;AAEI,wBAAM,sBAAsB,GAA+B,0BAA0B,CAAC,QAA3B,CAAoC,OAAO,CAAC,QAA5C,CAA3D;AAEA,wBAAM,kBAAkB,GAAyB;AAC7C,oBAAA,MAAM,EAAE,sBAAsB,CAAC,MADc;AAE7C,oBAAA,WAAW,EAAE,sBAAsB,CAAC,QAFS;AAG7C,oBAAA,EAAE,EAAE,sBAAsB,CAAC,aAHkB;AAI7C,oBAAA,MAAM,EAAE,sBAAsB,CAAC,MAJc;AAK7C,oBAAA,OAAO,EAAE,sBAAsB,CAAC,OALa;AAM7C,oBAAA,UAAU,EAAE,sBAAsB,CAAC,MANU;AAO7C,oBAAA,iBAAiB,EAAE,sBAAsB,CAAC;AAPG,mBAAjD;;AAUA,sBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,8BAA5C,EAA4E;AACxE,yBAAK,gCAAL,CAAsC,8BAAtC,CAAqE,KAAK,gCAA1E,EACI,IAAI,oBAAJ,CACI,kBADJ,EAEI,SAFJ,CADJ;AAIH;;AAED;;AAEJ;;AAEG;;AACH,qBAAK,cAAL;AAEI,wBAAM,kBAAkB,GAAyB;AAC7C,oBAAA,EAAE,EAAE,cAAc,CAAC;AAD0B,mBAAjD;;AAIA,sBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,+BAA5C,EAA6E;AACzE,yBAAK,gCAAL,CAAsC,+BAAtC,CAAsE,KAAK,gCAA3E,EACI,IAAI,oBAAJ,CAAyB,kBAAzB,EAA6C,SAA7C,CADJ;AAEH;;AAED;;AAEJ;;;AAGG;;AACH,qBAAK,mBAAL;AAEI;AACA,wBAAM,qBAAqB,GAAyB;AAChD,oBAAA,EAAE,EAAE,cAAc,CAAC;AAD6B,mBAApD;AAIA;;AAEJ,qBAAK,OAAL;AACI,wBAAM,KAAK,GAAG,IAAI,4BAAJ,CACV,MAAsB;AAClB,0BAAM,kBAAkB,GAAG,cAAc,CAAC,KAA1C;AACA,2BAAO,OAAO,CAAC,OAAR,CAAgB,kBAAhB,CAAP;AACH,mBAJS,EAKV,MAAsB;AAClB,0BAAM,kBAAkB,GAAG,cAAc,CAAC,KAA1C;AACA,2BAAO,OAAO,CAAC,OAAR,CAAgB,kBAAhB,CAAP;AACH,mBARS,CAAd;AASA,uBAAK,cAAL,GAAsB,KAAtB;AAEA;;AAEJ;;AAEG;;AACH;AACI;AA1NR;;AA4NA;;AAEJ;;AAEG;;AACH,iBAAK,SAAL;AAEA;;AAEG;;AACH,iBAAK,OAAL;AAEI,oBAAM,aAAa,GAA0B,qBAAqB,CAAC,QAAtB,CAA+B,OAAO,CAAC,QAAvC,CAA7C;AAEA,oBAAM,YAAY,GAAkC,IAAI,6BAAJ,CAAkC,aAAa,CAAC,aAAhD,EAChD,KAAK,eAAL,CAAqB,aAAa,CAAC,YAAnC,CADgD,EAEhD,aAAa,CAAC,QAFkC,EAGhD,SAHgD,EAIhD,SAJgD,EAKhD,aAAa,CAAC,WALkC,EAMhD,SANgD,EAOhD,SAPgD,EAQhD,OAAO,CAAC,QARwC,EAShD,SATgD,CAApD;;AAWA,kBAAI,aAAa,CAAC,OAAlB,EAA2B;AACvB;AACA,oBAAI,YAAY,CAAC,IAAb,KAAsB,SAAtB,IAAmC,YAAY,CAAC,IAAb,CAAkB,MAAlB,GAA2B,CAAlE,EAAqE;AACjE,kBAAA,SAAS,GAAG,IAAZ;AACH,iBAFD,MAEO,IAAI,aAAa,CAAC,EAAd,KAAqB,KAAK,0BAA9B,EAA0D;AAC7D;AACA;AACA,kBAAA,SAAS,GAAG,IAAZ;AACH,iBAJM,MAIA,CACH;AACH;;AAED,oBAAI,SAAJ,EAAe;AACX,sBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,mBAA5C,EAAiE;AAC7D,yBAAK,gCAAL,CAAsC,mBAAtC,CAA0D,KAAK,gCAA/D,EACI,IAAI,wCAAJ,CAA6C,kCAAkC,CAAC,KAAhF,EAAuF,YAAvF,EAAqG,SAArG,CADJ;AAEH;AACJ;AACJ,eAlBD,MAkBO,IAAI,YAAY,CAAC,IAAb,KAAsB,SAA1B,EAAqC;AACxC,qBAAK,0BAAL,GAAkC,aAAa,CAAC,EAAhD;;AACA,oBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,mBAA5C,EAAiE;AAC7D,uBAAK,gCAAL,CAAsC,mBAAtC,CAA0D,KAAK,gCAA/D,EACI,IAAI,wCAAJ,CAA6C,kCAAkC,CAAC,OAAhF,EAAyF,YAAzF,EAAuG,SAAvG,CADJ;AAEH;AACJ;;AAED;;AAEJ;;AAEG;;AACH,iBAAK,oBAAL;AAEI,oBAAM,WAAW,GAAwB,mBAAmB,CAAC,QAApB,CAA6B,OAAO,CAAC,QAArC,CAAzC;AAEA,oBAAM,UAAU,GAAkC,IAAI,6BAAJ,CAAkC,WAAW,CAAC,aAA9C,EAC9C,KAAK,eAAL,CAAqB,WAAW,CAAC,YAAjC,CAD8C,EAE9C,WAAW,CAAC,QAFkC,EAG9C,SAH8C,EAI9C,SAJ8C,EAK9C,WAAW,CAAC,YALkC,EAM9C,SAN8C,EAO9C,SAP8C,EAQ9C,SAR8C,EAS9C,OAAO,CAAC,QATsC,EAU9C,SAV8C,CAAlD;;AAYA,kBAAI,CAAC,CAAC,KAAK,gCAAL,CAAsC,mBAA5C,EAAiE;AAC7D,qBAAK,gCAAL,CAAsC,mBAAtC,CAA0D,KAAK,gCAA/D,EACI,IAAI,wCAAJ,CAA6C,kCAAkC,CAAC,cAAhF,EAAgG,UAAhG,EAA4G,SAA5G,CADJ;AAEH;;AACD;;AAEJ;AACI;AACA;AAjTR;AAmTH,SApTD,CAoTE,OAAO,CAAP,EAAU,CACR;AACH;;AACD,eAAO,KAAK,kCAAL,EAAP;AACH,OAxUD,CAwUE,OAAO,CAAP,EAAU;AACR,aAAK,oBAAL,GAA4B,IAA5B;AACH;;AAED,aAAO,sBAAsB,CAAC,OAA9B;AACH,K;AAAA;;AAEa,EAAA,gBAAgB,GAAA;;AAC1B,UAAI,KAAK,UAAL,EAAJ,EAAuB;AACnB,eAAO,OAAO,CAAC,OAAR,EAAP;AACH;;AACD,WAAK,oBAAL,GAA4B,KAA5B;AAEA,YAAM,uBAAuB,GAAG,KAAK,kCAAL,EAAhC;;AAEA,UAAI;AACA,cAAM,CAAC,GAAG,MAAM,uBAAhB;AACA,eAAO,CAAP;AACH,OAHD,CAGE,OAAO,KAAP,EAAc;AACZ,aAAK,iBAAL,CAAuB,KAAK,kBAAL,GAA0B,KAAK,kBAAL,CAAwB,SAAlD,GAA8D,EAArF,EAAyF,KAAK,kBAAL,GAA0B,KAAK,kBAAL,CAAwB,SAAlD,GAA8D,EAAvJ,EAA2J,kBAAkB,CAAC,KAA9K,EAAqL,qBAAqB,CAAC,YAA3M,EAAyN,KAAzN;AACA,eAAO,IAAP;AACH;AACJ,K;AAAA,GA9dgE,CAgejE;;;AACQ,EAAA,gBAAgB,GAAA;AACpB,QAAI,KAAK,UAAL,EAAJ,EAAuB;AACnB,aAAO,OAAO,CAAC,OAAR,CAA6B,SAA7B,CAAP;AACH;;AACD,QAAI,KAAK,2BAAL,KAAqC,SAAzC,EAAoD;AAChD,aAAO,KAAK,2BAAL,CAAiC,IAAjC,CAAuC,UAAD,IAAkD;AAC3F,YAAI,UAAU,CAAC,KAAX,OAAuB,eAAe,CAAC,YAA3C,EAAyD;AACrD,eAAK,gBAAL,GAAwB,IAAxB;AACA,eAAK,2BAAL,GAAmC,SAAnC;AACA,iBAAO,KAAK,gBAAL,EAAP;AACH;;AACD,eAAO,KAAK,2BAAZ;AACH,OAPM,EAOJ,MAA2B;AAC1B,aAAK,gBAAL,GAAwB,IAAxB;AACA,aAAK,2BAAL,GAAmC,SAAnC;AACA,eAAO,KAAK,gBAAL,EAAP;AACH,OAXM,CAAP;AAYH;;AACD,QAAI,KAAK,oBAAT,EAA+B;AAC3B,aAAO,OAAO,CAAC,OAAR,CAA6B,SAA7B,CAAP;AACH;;AAED,SAAK,2BAAL,GAAmC,KAAK,WAAL,GAAmB,IAAnB,CAAyB,UAAD,IAA0C,UAAlE,CAAnC;AAEA,WAAO,KAAK,2BAAZ;AACH;;AAEO,EAAA,eAAe,CAAC,yBAAD,EAAyD;AAC5E,QAAI,YAAJ;;AAEA,QAAI,SAAS,KAAK,yBAAlB,EAA6C;AACzC,MAAA,YAAY,GAAG,IAAI,YAAJ,EAAf;;AACA,WAAK,MAAM,WAAX,IAA0B,yBAA1B,EAAqD;AACjD,QAAA,YAAY,CAAC,GAAb,CAAiB,WAAW,CAAC,IAA7B,EAAmC,WAAW,CAAC,WAA/C;AACH;AACJ;;AAED,WAAO,YAAP;AACH;;AAvgBgE","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ConnectionState,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    IAudioSource,\r\n    IConnection,\r\n    MessageType,\r\n} from \"../../common/Exports\";\r\nimport {\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    ConversationExpirationEventArgs,\r\n    ConversationTranslationCanceledEventArgs,\r\n    ConversationTranslationResult,\r\n    Translations\r\n} from \"../../sdk/Exports\";\r\nimport {\r\n    CognitiveTokenAuthentication,\r\n    IAuthentication,\r\n    IConnectionFactory,\r\n    RecognizerConfig,\r\n    ServiceRecognizerBase\r\n} from \"../Exports\";\r\nimport { ConversationConnectionMessage } from \"./ConversationConnectionMessage\";\r\nimport { ConversationRequestSession } from \"./ConversationRequestSession\";\r\nimport {\r\n    ConversationReceivedTranslationEventArgs,\r\n    LockRoomEventArgs,\r\n    MuteAllEventArgs,\r\n    ParticipantAttributeEventArgs,\r\n    ParticipantEventArgs,\r\n    ParticipantsListEventArgs\r\n} from \"./ConversationTranslatorEventArgs\";\r\nimport {\r\n    ConversationTranslatorCommandTypes,\r\n    ConversationTranslatorMessageTypes,\r\n    IInternalParticipant\r\n} from \"./ConversationTranslatorInterfaces\";\r\nimport { ConversationTranslatorRecognizer } from \"./ConversationTranslatorRecognizer\";\r\nimport {\r\n    CommandResponsePayload,\r\n    IParticipantPayloadResponse,\r\n    IParticipantsListPayloadResponse,\r\n    ITranslationResponsePayload,\r\n    ParticipantPayloadResponse,\r\n    ParticipantsListPayloadResponse,\r\n    SpeechResponsePayload,\r\n    TextResponsePayload\r\n} from \"./ServiceMessages/Exports\";\r\n\r\n/**\r\n * The service adapter handles sending and receiving messages to the Conversation Translator websocket.\r\n */\r\nexport class ConversationServiceAdapter extends ServiceRecognizerBase {\r\n    private privConversationServiceConnector: ConversationTranslatorRecognizer;\r\n    private privConversationConnectionFactory: IConnectionFactory;\r\n    private privConversationAuthFetchEventId: string;\r\n    private privConversationAuthentication: IAuthentication;\r\n    private privConversationRequestSession: ConversationRequestSession;\r\n    private privConnectionConfigPromise: Promise<IConnection> = undefined;\r\n    private privConnectionLoop: Promise<void>;\r\n    private terminateMessageLoop: boolean;\r\n    private privLastPartialUtteranceId: string;\r\n    private privConversationIsDisposed: boolean;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: IConnectionFactory,\r\n        audioSource: IAudioSource,\r\n        recognizerConfig: RecognizerConfig,\r\n        conversationServiceConnector: ConversationTranslatorRecognizer) {\r\n\r\n        super(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector);\r\n\r\n        this.privLastPartialUtteranceId = \"\";\r\n        this.privConversationServiceConnector = conversationServiceConnector;\r\n        this.privConversationAuthentication = authentication;\r\n        this.receiveMessageOverride = (): Promise<void> => this.receiveConversationMessageOverride();\r\n        this.recognizeOverride = (): Promise<void> => this.noOp();\r\n        this.postConnectImplOverride = (connection: Promise<IConnection>): Promise<IConnection> => this.conversationConnectImpl(connection);\r\n        this.configConnectionOverride = (): Promise<IConnection> => this.configConnection();\r\n        this.disconnectOverride = (): Promise<void> => this.privDisconnect();\r\n        this.privConversationRequestSession = new ConversationRequestSession(createNoDashGuid());\r\n        this.privConversationConnectionFactory = connectionFactory;\r\n        this.privConversationIsDisposed = false;\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return super.isDisposed() || this.privConversationIsDisposed;\r\n    }\r\n\r\n    public async dispose(reason?: string): Promise<void> {\r\n        this.privConversationIsDisposed = true;\r\n        if (this.privConnectionConfigPromise !== undefined) {\r\n            const connection: IConnection = await this.privConnectionConfigPromise;\r\n            await connection.dispose(reason);\r\n        }\r\n        await super.dispose(reason);\r\n    }\r\n\r\n    public async sendMessage(message: string): Promise<void> {\r\n        const connection: IConnection = await this.fetchConnection();\r\n        return connection.send(new ConversationConnectionMessage(\r\n            MessageType.Text,\r\n            message));\r\n    }\r\n\r\n    public async sendMessageAsync(message: string): Promise<void> {\r\n        const connection: IConnection = await this.fetchConnection();\r\n\r\n        await connection.send(new ConversationConnectionMessage(MessageType.Text, message));\r\n    }\r\n\r\n    protected privDisconnect(): Promise<void> {\r\n        if (this.terminateMessageLoop) {\r\n            return;\r\n        }\r\n        this.cancelRecognition(this.privConversationRequestSession.sessionId,\r\n            this.privConversationRequestSession.requestId,\r\n            CancellationReason.Error,\r\n            CancellationErrorCode.NoError,\r\n            \"Disconnecting\");\r\n\r\n        this.terminateMessageLoop = true;\r\n        return Promise.resolve();\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/require-await\r\n    protected async processTypeSpecificMessages(): Promise<boolean> {\r\n        return true;\r\n    }\r\n\r\n    // Cancels recognition.\r\n    protected cancelRecognition(\r\n        sessionId: string,\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n\r\n        this.terminateMessageLoop = true;\r\n\r\n        const cancelEvent: ConversationTranslationCanceledEventArgs = new ConversationTranslationCanceledEventArgs(\r\n            cancellationReason,\r\n            error,\r\n            errorCode,\r\n            undefined,\r\n            sessionId);\r\n\r\n        try {\r\n            if (!!this.privConversationServiceConnector.canceled) {\r\n                this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, cancelEvent);\r\n            }\r\n        } catch {\r\n            // continue on error\r\n        }\r\n    }\r\n\r\n    protected noOp(): Promise<void> {\r\n        // operation not supported\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * Establishes a websocket connection to the end point.\r\n     */\r\n    protected async conversationConnectImpl(connection: Promise<IConnection>): Promise<IConnection> {\r\n        this.privConnectionLoop = this.startMessageLoop();\r\n        return connection;\r\n    }\r\n\r\n    /**\r\n     * Process incoming websocket messages\r\n     */\r\n    private async receiveConversationMessageOverride(): Promise<void> {\r\n        if (this.isDisposed() || this.terminateMessageLoop) {\r\n            return Promise.resolve();\r\n        }\r\n        // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\r\n        const communicationCustodian: Deferred<void> = new Deferred<void>();\r\n\r\n        try {\r\n            const connection: IConnection = await this.fetchConnection();\r\n            const message: ConversationConnectionMessage = await connection.read() as ConversationConnectionMessage;\r\n            if (this.isDisposed() || this.terminateMessageLoop) {\r\n                // We're done.\r\n                communicationCustodian.resolve();\r\n                return Promise.resolve();\r\n            }\r\n\r\n            if (!message) {\r\n                return this.receiveConversationMessageOverride();\r\n            }\r\n\r\n            const sessionId: string = this.privConversationRequestSession.sessionId;\r\n            let sendFinal: boolean = false;\r\n\r\n            try {\r\n                switch (message.conversationMessageType.toLowerCase()) {\r\n                    case \"info\":\r\n                    case \"participant_command\":\r\n                    case \"command\":\r\n                        const commandPayload: CommandResponsePayload = CommandResponsePayload.fromJSON(message.textBody);\r\n                        switch (commandPayload.command.toLowerCase()) {\r\n\r\n                            /**\r\n                             * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.\r\n                             * The consuming client must wait for this message to arrive\r\n                             * before starting to send their own data.\r\n                             */\r\n                            case \"participantlist\":\r\n\r\n                                const participantsPayload: IParticipantsListPayloadResponse = ParticipantsListPayloadResponse.fromJSON(message.textBody);\r\n\r\n                                const participantsResult: IInternalParticipant[] = participantsPayload.participants.map((p: IParticipantPayloadResponse): IInternalParticipant => {\r\n                                    const participant: IInternalParticipant = {\r\n                                        avatar: p.avatar,\r\n                                        displayName: p.nickname,\r\n                                        id: p.participantId,\r\n                                        isHost: p.ishost,\r\n                                        isMuted: p.ismuted,\r\n                                        isUsingTts: p.usetts,\r\n                                        preferredLanguage: p.locale\r\n                                    };\r\n                                    return participant;\r\n                                });\r\n\r\n                                if (!!this.privConversationServiceConnector.participantsListReceived) {\r\n                                    this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantsListEventArgs(participantsPayload.roomid, participantsPayload.token,\r\n                                            participantsPayload.translateTo, participantsPayload.profanityFilter,\r\n                                            participantsPayload.roomProfanityFilter, participantsPayload.roomLocked,\r\n                                            participantsPayload.muteAll, participantsResult, sessionId));\r\n                                }\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).\r\n                             * This is sent at the start of the Conversation\r\n                             */\r\n                            case \"settranslatetolanguages\":\r\n\r\n                                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                            ConversationTranslatorCommandTypes.setTranslateToLanguages,\r\n                                            commandPayload.value, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetProfanityFiltering' lets the client set the level of profanity filtering.\r\n                             * If sent by the participant the setting will effect only their own profanity level.\r\n                             * If sent by the host, the setting will effect all participants including the host.\r\n                             * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'\r\n                             */\r\n                            case \"setprofanityfiltering\":\r\n\r\n                                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                            ConversationTranslatorCommandTypes.setProfanityFiltering,\r\n                                            commandPayload.value, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetMute' is sent if the participant has been muted by the host.\r\n                             * Check the 'participantId' to determine if the current user has been muted.\r\n                             */\r\n                            case \"setmute\":\r\n\r\n                                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                            ConversationTranslatorCommandTypes.setMute,\r\n                                            commandPayload.value, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetMuteAll' is sent if the Conversation has been muted by the host.\r\n                             */\r\n                            case \"setmuteall\":\r\n\r\n                                if (!!this.privConversationServiceConnector.muteAllCommandReceived) {\r\n                                    this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector,\r\n                                        new MuteAllEventArgs(commandPayload.value as boolean, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.\r\n                             */\r\n                            case \"roomexpirationwarning\":\r\n\r\n                                if (!!this.privConversationServiceConnector.conversationExpiration) {\r\n                                    this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector,\r\n                                        new ConversationExpirationEventArgs(commandPayload.value as number, this.privConversationRequestSession.sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.\r\n                             */\r\n                            case \"setusetts\":\r\n\r\n                                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                            ConversationTranslatorCommandTypes.setUseTTS,\r\n                                            commandPayload.value, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetLockState' is set if the host has locked or unlocked the Conversation.\r\n                             */\r\n                            case \"setlockstate\":\r\n\r\n                                if (!!this.privConversationServiceConnector.lockRoomCommandReceived) {\r\n                                    this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector,\r\n                                        new LockRoomEventArgs(commandPayload.value as boolean, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'ChangeNickname' is received if a user changes their display name.\r\n                             * Any cached particpiants list should be updated to reflect the display name.\r\n                             */\r\n                            case \"changenickname\":\r\n\r\n                                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                            ConversationTranslatorCommandTypes.changeNickname,\r\n                                            commandPayload.nickname, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'JoinSession' is sent when a user joins the Conversation.\r\n                             */\r\n                            case \"joinsession\":\r\n\r\n                                const joinParticipantPayload: ParticipantPayloadResponse = ParticipantPayloadResponse.fromJSON(message.textBody);\r\n\r\n                                const joiningParticipant: IInternalParticipant = {\r\n                                    avatar: joinParticipantPayload.avatar,\r\n                                    displayName: joinParticipantPayload.nickname,\r\n                                    id: joinParticipantPayload.participantId,\r\n                                    isHost: joinParticipantPayload.ishost,\r\n                                    isMuted: joinParticipantPayload.ismuted,\r\n                                    isUsingTts: joinParticipantPayload.usetts,\r\n                                    preferredLanguage: joinParticipantPayload.locale,\r\n                                };\r\n\r\n                                if (!!this.privConversationServiceConnector.participantJoinCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantEventArgs(\r\n                                            joiningParticipant,\r\n                                            sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'LeaveSession' is sent when a user leaves the Conversation'.\r\n                             */\r\n                            case \"leavesession\":\r\n\r\n                                const leavingParticipant: IInternalParticipant = {\r\n                                    id: commandPayload.participantId\r\n                                };\r\n\r\n                                if (!!this.privConversationServiceConnector.participantLeaveCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantEventArgs(leavingParticipant, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).\r\n                             * Check the 'ParticipantId' to check whether the message is for the current user.\r\n                             */\r\n                            case \"disconnectsession\":\r\n\r\n                                // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n                                const disconnectParticipant: IInternalParticipant = {\r\n                                    id: commandPayload.participantId\r\n                                };\r\n\r\n                                break;\r\n\r\n                            case \"token\":\r\n                                const token = new CognitiveTokenAuthentication(\r\n                                    (): Promise<string> => {\r\n                                        const authorizationToken = commandPayload.token;\r\n                                        return Promise.resolve(authorizationToken);\r\n                                    },\r\n                                    (): Promise<string> => {\r\n                                        const authorizationToken = commandPayload.token;\r\n                                        return Promise.resolve(authorizationToken);\r\n                                    });\r\n                                this.authentication = token;\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * Message not recognized.\r\n                             */\r\n                            default:\r\n                                break;\r\n                        }\r\n                        break;\r\n\r\n                    /**\r\n                     * 'partial' (or 'hypothesis') represents a unfinalized speech message.\r\n                     */\r\n                    case \"partial\":\r\n\r\n                    /**\r\n                     * 'final' (or 'phrase') represents a finalized speech message.\r\n                     */\r\n                    case \"final\":\r\n\r\n                        const speechPayload: SpeechResponsePayload = SpeechResponsePayload.fromJSON(message.textBody);\r\n\r\n                        const speechResult: ConversationTranslationResult = new ConversationTranslationResult(speechPayload.participantId,\r\n                            this.getTranslations(speechPayload.translations),\r\n                            speechPayload.language,\r\n                            undefined,\r\n                            undefined,\r\n                            speechPayload.recognition,\r\n                            undefined,\r\n                            undefined,\r\n                            message.textBody,\r\n                            undefined);\r\n\r\n                        if (speechPayload.isFinal) {\r\n                            // check the length, sometimes empty finals are returned\r\n                            if (speechResult.text !== undefined && speechResult.text.length > 0) {\r\n                                sendFinal = true;\r\n                            } else if (speechPayload.id === this.privLastPartialUtteranceId) {\r\n                                // send final as normal. We had a non-empty partial for this same utterance\r\n                                // so sending the empty final is important\r\n                                sendFinal = true;\r\n                            } else {\r\n                                // suppress unneeded final\r\n                            }\r\n\r\n                            if (sendFinal) {\r\n                                if (!!this.privConversationServiceConnector.translationReceived) {\r\n                                    this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                        new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.final, speechResult, sessionId));\r\n                                }\r\n                            }\r\n                        } else if (speechResult.text !== undefined) {\r\n                            this.privLastPartialUtteranceId = speechPayload.id;\r\n                            if (!!this.privConversationServiceConnector.translationReceived) {\r\n                                this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                    new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.partial, speechResult, sessionId));\r\n                            }\r\n                        }\r\n\r\n                        break;\r\n\r\n                    /**\r\n                     * \"translated_message\" is a text message or instant message (IM).\r\n                     */\r\n                    case \"translated_message\":\r\n\r\n                        const textPayload: TextResponsePayload = TextResponsePayload.fromJSON(message.textBody);\r\n\r\n                        const textResult: ConversationTranslationResult = new ConversationTranslationResult(textPayload.participantId,\r\n                            this.getTranslations(textPayload.translations),\r\n                            textPayload.language,\r\n                            undefined,\r\n                            undefined,\r\n                            textPayload.originalText,\r\n                            undefined,\r\n                            undefined,\r\n                            undefined,\r\n                            message.textBody,\r\n                            undefined);\r\n\r\n                        if (!!this.privConversationServiceConnector.translationReceived) {\r\n                            this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.instantMessage, textResult, sessionId));\r\n                        }\r\n                        break;\r\n\r\n                    default:\r\n                        // ignore any unsupported message types\r\n                        break;\r\n                }\r\n            } catch (e) {\r\n                // continue\r\n            }\r\n            return this.receiveConversationMessageOverride();\r\n        } catch (e) {\r\n            this.terminateMessageLoop = true;\r\n        }\r\n\r\n        return communicationCustodian.promise;\r\n    }\r\n\r\n    private async startMessageLoop(): Promise<void> {\r\n        if (this.isDisposed()) {\r\n            return Promise.resolve();\r\n        }\r\n        this.terminateMessageLoop = false;\r\n\r\n        const messageRetrievalPromise = this.receiveConversationMessageOverride();\r\n\r\n        try {\r\n            const r = await messageRetrievalPromise;\r\n            return r;\r\n        } catch (error) {\r\n            this.cancelRecognition(this.privRequestSession ? this.privRequestSession.sessionId : \"\", this.privRequestSession ? this.privRequestSession.requestId : \"\", CancellationReason.Error, CancellationErrorCode.RuntimeError, error as string);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Takes an established websocket connection to the endpoint\r\n    private configConnection(): Promise<IConnection> {\r\n        if (this.isDisposed()) {\r\n            return Promise.resolve<IConnection>(undefined);\r\n        }\r\n        if (this.privConnectionConfigPromise !== undefined) {\r\n            return this.privConnectionConfigPromise.then((connection: IConnection): Promise<IConnection> => {\r\n                if (connection.state() === ConnectionState.Disconnected) {\r\n                    this.privConnectionId = null;\r\n                    this.privConnectionConfigPromise = undefined;\r\n                    return this.configConnection();\r\n                }\r\n                return this.privConnectionConfigPromise;\r\n            }, (): Promise<IConnection> => {\r\n                this.privConnectionId = null;\r\n                this.privConnectionConfigPromise = undefined;\r\n                return this.configConnection();\r\n            });\r\n        }\r\n        if (this.terminateMessageLoop) {\r\n            return Promise.resolve<IConnection>(undefined);\r\n        }\r\n\r\n        this.privConnectionConfigPromise = this.connectImpl().then((connection: IConnection): IConnection => connection);\r\n\r\n        return this.privConnectionConfigPromise;\r\n    }\r\n\r\n    private getTranslations(serviceResultTranslations: ITranslationResponsePayload[]): Translations {\r\n        let translations: Translations;\r\n\r\n        if (undefined !== serviceResultTranslations) {\r\n            translations = new Translations();\r\n            for (const translation of serviceResultTranslations) {\r\n                translations.set(translation.lang, translation.translation);\r\n            }\r\n        }\r\n\r\n        return translations;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}