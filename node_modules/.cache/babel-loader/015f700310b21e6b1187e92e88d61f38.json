{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { Deferred, MessageType, RawWebsocketMessage } from \"../../common/Exports\";\nimport { ConversationConnectionMessage } from \"./ConversationConnectionMessage\";\n/**\n * Based off WebsocketMessageFormatter. The messages for Conversation Translator have some variations from the Speech messages.\n */\n\nexport class ConversationWebsocketMessageFormatter {\n  /**\n   * Format incoming messages: text (speech partial/final, IM) or binary (tts)\n   */\n  toConnectionMessage(message) {\n    const deferral = new Deferred();\n\n    try {\n      if (message.messageType === MessageType.Text) {\n        const incomingMessage = new ConversationConnectionMessage(message.messageType, message.textContent, {}, message.id);\n        deferral.resolve(incomingMessage);\n      } else if (message.messageType === MessageType.Binary) {\n        deferral.resolve(new ConversationConnectionMessage(message.messageType, message.binaryContent, undefined, message.id));\n      }\n    } catch (e) {\n      deferral.reject(`Error formatting the message. Error: ${e}`);\n    }\n\n    return deferral.promise;\n  }\n  /**\n   * Format outgoing messages: text (commands or IM)\n   */\n\n\n  fromConnectionMessage(message) {\n    const deferral = new Deferred();\n\n    try {\n      if (message.messageType === MessageType.Text) {\n        const payload = `${message.textBody ? message.textBody : \"\"}`;\n        deferral.resolve(new RawWebsocketMessage(MessageType.Text, payload, message.id));\n      }\n    } catch (e) {\n      deferral.reject(`Error formatting the message. ${e}`);\n    }\n\n    return deferral.promise;\n  }\n\n}","map":{"version":3,"sources":["src/common.speech/Transcription/ConversationWebsocketMessageFormatter.ts"],"names":[],"mappings":"AAAA;AACA;AAEA,SAEI,QAFJ,EAII,WAJJ,EAKI,mBALJ,QAMO,sBANP;AAOA,SAAS,6BAAT,QAA8C,iCAA9C;AAEA;;AAEG;;AACH,OAAM,MAAO,qCAAP,CAA4C;AAE9C;;AAEG;AACI,EAAA,mBAAmB,CAAC,OAAD,EAA6B;AACnD,UAAM,QAAQ,GAAG,IAAI,QAAJ,EAAjB;;AAEA,QAAI;AACA,UAAI,OAAO,CAAC,WAAR,KAAwB,WAAW,CAAC,IAAxC,EAA8C;AAC1C,cAAM,eAAe,GAAkC,IAAI,6BAAJ,CAAkC,OAAO,CAAC,WAA1C,EAAuD,OAAO,CAAC,WAA/D,EAA4E,EAA5E,EAAgF,OAAO,CAAC,EAAxF,CAAvD;AACA,QAAA,QAAQ,CAAC,OAAT,CAAiB,eAAjB;AACH,OAHD,MAGO,IAAI,OAAO,CAAC,WAAR,KAAwB,WAAW,CAAC,MAAxC,EAAgD;AACnD,QAAA,QAAQ,CAAC,OAAT,CAAiB,IAAI,6BAAJ,CAAkC,OAAO,CAAC,WAA1C,EAAuD,OAAO,CAAC,aAA/D,EAA8E,SAA9E,EAAyF,OAAO,CAAC,EAAjG,CAAjB;AACH;AACJ,KAPD,CAOE,OAAO,CAAP,EAAU;AACR,MAAA,QAAQ,CAAC,MAAT,CAAgB,wCAAwC,CAAW,EAAnE;AACH;;AAED,WAAO,QAAQ,CAAC,OAAhB;AACH;AAED;;AAEG;;;AACI,EAAA,qBAAqB,CAAC,OAAD,EAA2B;AAEnD,UAAM,QAAQ,GAAG,IAAI,QAAJ,EAAjB;;AAEA,QAAI;AACA,UAAI,OAAO,CAAC,WAAR,KAAwB,WAAW,CAAC,IAAxC,EAA8C;AAC1C,cAAM,OAAO,GAAG,GAAG,OAAO,CAAC,QAAR,GAAmB,OAAO,CAAC,QAA3B,GAAsC,EAAE,EAA3D;AACA,QAAA,QAAQ,CAAC,OAAT,CAAiB,IAAI,mBAAJ,CAAwB,WAAW,CAAC,IAApC,EAA0C,OAA1C,EAAmD,OAAO,CAAC,EAA3D,CAAjB;AACH;AACJ,KALD,CAKE,OAAO,CAAP,EAAU;AACR,MAAA,QAAQ,CAAC,MAAT,CAAgB,iCAAiC,CAAW,EAA5D;AACH;;AAED,WAAO,QAAQ,CAAC,OAAhB;AACH;;AAvC6C","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ConnectionMessage,\r\n    Deferred,\r\n    IWebsocketMessageFormatter,\r\n    MessageType,\r\n    RawWebsocketMessage,\r\n} from \"../../common/Exports\";\r\nimport { ConversationConnectionMessage } from \"./ConversationConnectionMessage\";\r\n\r\n/**\r\n * Based off WebsocketMessageFormatter. The messages for Conversation Translator have some variations from the Speech messages.\r\n */\r\nexport class ConversationWebsocketMessageFormatter implements IWebsocketMessageFormatter {\r\n\r\n    /**\r\n     * Format incoming messages: text (speech partial/final, IM) or binary (tts)\r\n     */\r\n    public toConnectionMessage(message: RawWebsocketMessage): Promise<ConversationConnectionMessage> {\r\n        const deferral = new Deferred<ConversationConnectionMessage>();\r\n\r\n        try {\r\n            if (message.messageType === MessageType.Text) {\r\n                const incomingMessage: ConversationConnectionMessage = new ConversationConnectionMessage(message.messageType, message.textContent, {}, message.id);\r\n                deferral.resolve(incomingMessage);\r\n            } else if (message.messageType === MessageType.Binary) {\r\n                deferral.resolve(new ConversationConnectionMessage(message.messageType, message.binaryContent, undefined, message.id));\r\n            }\r\n        } catch (e) {\r\n            deferral.reject(`Error formatting the message. Error: ${e as string}`);\r\n        }\r\n\r\n        return deferral.promise;\r\n    }\r\n\r\n    /**\r\n     * Format outgoing messages: text (commands or IM)\r\n     */\r\n    public fromConnectionMessage(message: ConnectionMessage): Promise<RawWebsocketMessage> {\r\n\r\n        const deferral = new Deferred<RawWebsocketMessage>();\r\n\r\n        try {\r\n            if (message.messageType === MessageType.Text) {\r\n                const payload = `${message.textBody ? message.textBody : \"\"}`;\r\n                deferral.resolve(new RawWebsocketMessage(MessageType.Text, payload, message.id));\r\n            }\r\n        } catch (e) {\r\n            deferral.reject(`Error formatting the message. ${e as string}`);\r\n        }\r\n\r\n        return deferral.promise;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}