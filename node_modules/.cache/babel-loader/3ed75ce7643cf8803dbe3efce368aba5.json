{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { createNoDashGuid, Deferred, Events } from \"../common/Exports\";\nimport { PullAudioOutputStreamImpl } from \"../sdk/Audio/AudioOutputStream\";\nimport { MetadataType } from \"./ServiceMessages/SynthesisAudioMetadata\";\nimport { SynthesisAdapterBase } from \"./SynthesisAdapterBase\";\nimport { ConnectingToSynthesisServiceEvent, SynthesisStartedEvent, SynthesisTriggeredEvent } from \"./SynthesisEvents\";\nexport class SynthesisTurn {\n  constructor() {\n    this.privIsDisposed = false;\n    this.privIsSynthesizing = false;\n    this.privIsSynthesisEnded = false;\n    this.privBytesReceived = 0;\n    this.privInTurn = false;\n    this.privTextOffset = 0;\n    this.privNextSearchTextIndex = 0;\n    this.privSentenceOffset = 0;\n    this.privNextSearchSentenceIndex = 0;\n    this.privRequestId = createNoDashGuid();\n    this.privTurnDeferral = new Deferred(); // We're not in a turn, so resolve.\n\n    this.privTurnDeferral.resolve();\n  }\n\n  get requestId() {\n    return this.privRequestId;\n  }\n\n  get streamId() {\n    return this.privStreamId;\n  }\n\n  set streamId(value) {\n    this.privStreamId = value;\n  }\n\n  get audioOutputFormat() {\n    return this.privAudioOutputFormat;\n  }\n\n  set audioOutputFormat(format) {\n    this.privAudioOutputFormat = format;\n  }\n\n  get turnCompletionPromise() {\n    return this.privTurnDeferral.promise;\n  }\n\n  get isSynthesisEnded() {\n    return this.privIsSynthesisEnded;\n  }\n\n  get isSynthesizing() {\n    return this.privIsSynthesizing;\n  }\n\n  get currentTextOffset() {\n    return this.privTextOffset;\n  }\n\n  get currentSentenceOffset() {\n    return this.privSentenceOffset;\n  } // The number of bytes received for current turn\n\n\n  get bytesReceived() {\n    return this.privBytesReceived;\n  }\n\n  get audioDuration() {\n    return this.privAudioDuration;\n  }\n\n  getAllReceivedAudio() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!!this.privReceivedAudio) {\n        return Promise.resolve(this.privReceivedAudio);\n      }\n\n      if (!this.privIsSynthesisEnded) {\n        return null;\n      }\n\n      yield this.readAllAudioFromStream();\n      return Promise.resolve(this.privReceivedAudio);\n    });\n  }\n\n  getAllReceivedAudioWithHeader() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!!this.privReceivedAudioWithHeader) {\n        return this.privReceivedAudioWithHeader;\n      }\n\n      if (!this.privIsSynthesisEnded) {\n        return null;\n      }\n\n      if (this.audioOutputFormat.hasHeader) {\n        const audio = yield this.getAllReceivedAudio();\n        this.privReceivedAudioWithHeader = SynthesisAdapterBase.addHeader(audio, this.audioOutputFormat);\n        return this.privReceivedAudioWithHeader;\n      } else {\n        return this.getAllReceivedAudio();\n      }\n    });\n  }\n\n  startNewSynthesis(requestId, rawText, isSSML, audioDestination) {\n    this.privIsSynthesisEnded = false;\n    this.privIsSynthesizing = true;\n    this.privRequestId = requestId;\n    this.privRawText = rawText;\n    this.privIsSSML = isSSML;\n    this.privAudioOutputStream = new PullAudioOutputStreamImpl();\n    this.privAudioOutputStream.format = this.privAudioOutputFormat;\n    this.privReceivedAudio = null;\n    this.privReceivedAudioWithHeader = null;\n    this.privBytesReceived = 0;\n    this.privTextOffset = 0;\n    this.privNextSearchTextIndex = 0;\n    this.privSentenceOffset = 0;\n    this.privNextSearchSentenceIndex = 0;\n    this.privPartialVisemeAnimation = \"\";\n\n    if (audioDestination !== undefined) {\n      this.privTurnAudioDestination = audioDestination;\n      this.privTurnAudioDestination.format = this.privAudioOutputFormat;\n    }\n\n    this.onEvent(new SynthesisTriggeredEvent(this.requestId, undefined, audioDestination === undefined ? undefined : audioDestination.id()));\n  }\n\n  onPreConnectionStart(authFetchEventId) {\n    this.privAuthFetchEventId = authFetchEventId;\n    this.onEvent(new ConnectingToSynthesisServiceEvent(this.privRequestId, this.privAuthFetchEventId));\n  }\n\n  onAuthCompleted(isError) {\n    if (isError) {\n      this.onComplete();\n    }\n  }\n\n  onConnectionEstablishCompleted(statusCode) {\n    if (statusCode === 200) {\n      this.onEvent(new SynthesisStartedEvent(this.requestId, this.privAuthFetchEventId));\n      this.privBytesReceived = 0;\n      return;\n    } else if (statusCode === 403) {\n      this.onComplete();\n    }\n  }\n\n  onServiceResponseMessage(responseJson) {\n    const response = JSON.parse(responseJson);\n    this.streamId = response.audio.streamId;\n  }\n\n  onServiceTurnEndResponse() {\n    this.privInTurn = false;\n    this.privTurnDeferral.resolve();\n    this.onComplete();\n  }\n\n  onServiceTurnStartResponse() {\n    if (!!this.privTurnDeferral && !!this.privInTurn) {\n      // What? How are we starting a turn with another not done?\n      this.privTurnDeferral.reject(\"Another turn started before current completed.\"); // Avoid UnhandledPromiseRejection if privTurnDeferral is not being awaited\n      // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n      this.privTurnDeferral.promise.then().catch(() => {});\n    }\n\n    this.privInTurn = true;\n    this.privTurnDeferral = new Deferred();\n  }\n\n  onAudioChunkReceived(data) {\n    if (this.isSynthesizing) {\n      this.privAudioOutputStream.write(data);\n      this.privBytesReceived += data.byteLength;\n\n      if (this.privTurnAudioDestination !== undefined) {\n        this.privTurnAudioDestination.write(data);\n      }\n    }\n  }\n\n  onTextBoundaryEvent(metadata) {\n    this.updateTextOffset(metadata.Data.text.Text, metadata.Type);\n  }\n\n  onVisemeMetadataReceived(metadata) {\n    if (metadata.Data.AnimationChunk !== undefined) {\n      this.privPartialVisemeAnimation += metadata.Data.AnimationChunk;\n    }\n  }\n\n  onSessionEnd(metadata) {\n    this.privAudioDuration = metadata.Data.Offset;\n  }\n\n  dispose() {\n    if (!this.privIsDisposed) {\n      // we should have completed by now. If we did not its an unknown error.\n      this.privIsDisposed = true;\n    }\n  }\n\n  onStopSynthesizing() {\n    this.onComplete();\n  }\n  /**\n   * Gets the viseme animation string (merged from animation chunk), and clears the internal\n   * partial animation.\n   */\n\n\n  getAndClearVisemeAnimation() {\n    const animation = this.privPartialVisemeAnimation;\n    this.privPartialVisemeAnimation = \"\";\n    return animation;\n  }\n\n  onEvent(event) {\n    Events.instance.onEvent(event);\n  }\n  /**\n   * Check if the text is an XML(SSML) tag\n   * @param text\n   * @private\n   */\n\n\n  static isXmlTag(text) {\n    return text.length >= 2 && text[0] === \"<\" && text[text.length - 1] === \">\";\n  }\n\n  updateTextOffset(text, type) {\n    if (type === MetadataType.WordBoundary) {\n      this.privTextOffset = this.privRawText.indexOf(text, this.privNextSearchTextIndex);\n\n      if (this.privTextOffset >= 0) {\n        this.privNextSearchTextIndex = this.privTextOffset + text.length;\n\n        if (this.privIsSSML) {\n          if (this.withinXmlTag(this.privTextOffset) && !SynthesisTurn.isXmlTag(text)) {\n            this.updateTextOffset(text, type);\n          }\n        }\n      }\n    } else {\n      this.privSentenceOffset = this.privRawText.indexOf(text, this.privNextSearchSentenceIndex);\n\n      if (this.privSentenceOffset >= 0) {\n        this.privNextSearchSentenceIndex = this.privSentenceOffset + text.length;\n\n        if (this.privIsSSML) {\n          if (this.withinXmlTag(this.privSentenceOffset) && !SynthesisTurn.isXmlTag(text)) {\n            this.updateTextOffset(text, type);\n          }\n        }\n      }\n    }\n  }\n\n  onComplete() {\n    if (this.privIsSynthesizing) {\n      this.privIsSynthesizing = false;\n      this.privIsSynthesisEnded = true;\n      this.privAudioOutputStream.close();\n      this.privInTurn = false;\n\n      if (this.privTurnAudioDestination !== undefined) {\n        this.privTurnAudioDestination.close();\n        this.privTurnAudioDestination = undefined;\n      }\n    }\n  }\n\n  readAllAudioFromStream() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.privIsSynthesisEnded) {\n        this.privReceivedAudio = new ArrayBuffer(this.bytesReceived);\n\n        try {\n          yield this.privAudioOutputStream.read(this.privReceivedAudio);\n        } catch (e) {\n          this.privReceivedAudio = new ArrayBuffer(0);\n        }\n      }\n    });\n  }\n  /**\n   * Check if current idx is in XML(SSML) tag\n   * @param idx\n   * @private\n   */\n\n\n  withinXmlTag(idx) {\n    return this.privRawText.indexOf(\"<\", idx + 1) > this.privRawText.indexOf(\">\", idx + 1);\n  }\n\n}","map":{"version":3,"sources":["src/common.speech/SynthesisTurn.ts"],"names":[],"mappings":"AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,SACI,gBADJ,EAEI,QAFJ,EAGI,MAHJ,QAKO,mBALP;AAOA,SAAS,yBAAT,QAA0C,gCAA1C;AACA,SAA6B,YAA7B,QAAiD,0CAAjD;AACA,SAAS,oBAAT,QAAqC,wBAArC;AACA,SACI,iCADJ,EAGI,qBAHJ,EAII,uBAJJ,QAKO,mBALP;AAqBA,OAAM,MAAO,aAAP,CAAoB;AA0EtB,EAAA,WAAA,GAAA;AAvBQ,SAAA,cAAA,GAA0B,KAA1B;AAEA,SAAA,kBAAA,GAA8B,KAA9B;AACA,SAAA,oBAAA,GAAgC,KAAhC;AACA,SAAA,iBAAA,GAA4B,CAA5B;AAIA,SAAA,UAAA,GAAsB,KAAtB;AAKA,SAAA,cAAA,GAAyB,CAAzB;AACA,SAAA,uBAAA,GAAkC,CAAlC;AACA,SAAA,kBAAA,GAA6B,CAA7B;AACA,SAAA,2BAAA,GAAsC,CAAtC;AAQJ,SAAK,aAAL,GAAqB,gBAAgB,EAArC;AACA,SAAK,gBAAL,GAAwB,IAAI,QAAJ,EAAxB,CAFJ,CAII;;AACA,SAAK,gBAAL,CAAsB,OAAtB;AACH;;AA9ED,MAAW,SAAX,GAAoB;AAChB,WAAO,KAAK,aAAZ;AACH;;AAED,MAAW,QAAX,GAAmB;AACf,WAAO,KAAK,YAAZ;AACH;;AAED,MAAW,QAAX,CAAoB,KAApB,EAAiC;AAC7B,SAAK,YAAL,GAAoB,KAApB;AACH;;AAED,MAAW,iBAAX,GAA4B;AACxB,WAAO,KAAK,qBAAZ;AACH;;AAED,MAAW,iBAAX,CAA6B,MAA7B,EAA0D;AACtD,SAAK,qBAAL,GAA6B,MAA7B;AACH;;AAED,MAAW,qBAAX,GAAgC;AAC5B,WAAO,KAAK,gBAAL,CAAsB,OAA7B;AACH;;AAED,MAAW,gBAAX,GAA2B;AACvB,WAAO,KAAK,oBAAZ;AACH;;AAED,MAAW,cAAX,GAAyB;AACrB,WAAO,KAAK,kBAAZ;AACH;;AAED,MAAW,iBAAX,GAA4B;AACxB,WAAO,KAAK,cAAZ;AACH;;AAED,MAAW,qBAAX,GAAgC;AAC5B,WAAO,KAAK,kBAAZ;AACH,GAxCqB,CA0CtB;;;AACA,MAAW,aAAX,GAAwB;AACpB,WAAO,KAAK,iBAAZ;AACH;;AAED,MAAW,aAAX,GAAwB;AACpB,WAAO,KAAK,iBAAZ;AACH;;AAiCY,EAAA,mBAAmB,GAAA;;AAC5B,UAAI,CAAC,CAAC,KAAK,iBAAX,EAA8B;AAC1B,eAAO,OAAO,CAAC,OAAR,CAAgB,KAAK,iBAArB,CAAP;AACH;;AACD,UAAI,CAAC,KAAK,oBAAV,EAAgC;AAC5B,eAAO,IAAP;AACH;;AACD,YAAM,KAAK,sBAAL,EAAN;AACA,aAAO,OAAO,CAAC,OAAR,CAAgB,KAAK,iBAArB,CAAP;AACH,K;AAAA;;AAEY,EAAA,6BAA6B,GAAA;;AACtC,UAAI,CAAC,CAAC,KAAK,2BAAX,EAAwC;AACpC,eAAO,KAAK,2BAAZ;AACH;;AACD,UAAI,CAAC,KAAK,oBAAV,EAAgC;AAC5B,eAAO,IAAP;AACH;;AACD,UAAI,KAAK,iBAAL,CAAuB,SAA3B,EAAsC;AAClC,cAAM,KAAK,GAAgB,MAAM,KAAK,mBAAL,EAAjC;AACA,aAAK,2BAAL,GAAmC,oBAAoB,CAAC,SAArB,CAA+B,KAA/B,EAAsC,KAAK,iBAA3C,CAAnC;AACA,eAAO,KAAK,2BAAZ;AACH,OAJD,MAIO;AACH,eAAO,KAAK,mBAAL,EAAP;AACH;AACJ,K;AAAA;;AAEM,EAAA,iBAAiB,CAAC,SAAD,EAAoB,OAApB,EAAqC,MAArC,EAAsD,gBAAtD,EAA0F;AAC9G,SAAK,oBAAL,GAA4B,KAA5B;AACA,SAAK,kBAAL,GAA0B,IAA1B;AACA,SAAK,aAAL,GAAqB,SAArB;AACA,SAAK,WAAL,GAAmB,OAAnB;AACA,SAAK,UAAL,GAAkB,MAAlB;AACA,SAAK,qBAAL,GAA6B,IAAI,yBAAJ,EAA7B;AACA,SAAK,qBAAL,CAA2B,MAA3B,GAAoC,KAAK,qBAAzC;AACA,SAAK,iBAAL,GAAyB,IAAzB;AACA,SAAK,2BAAL,GAAmC,IAAnC;AACA,SAAK,iBAAL,GAAyB,CAAzB;AACA,SAAK,cAAL,GAAsB,CAAtB;AACA,SAAK,uBAAL,GAA+B,CAA/B;AACA,SAAK,kBAAL,GAA0B,CAA1B;AACA,SAAK,2BAAL,GAAmC,CAAnC;AACA,SAAK,0BAAL,GAAkC,EAAlC;;AACA,QAAI,gBAAgB,KAAK,SAAzB,EAAoC;AAChC,WAAK,wBAAL,GAAgC,gBAAhC;AACA,WAAK,wBAAL,CAA8B,MAA9B,GAAuC,KAAK,qBAA5C;AACH;;AACD,SAAK,OAAL,CAAa,IAAI,uBAAJ,CAA4B,KAAK,SAAjC,EAA4C,SAA5C,EAAuD,gBAAgB,KAAK,SAArB,GAAiC,SAAjC,GAA6C,gBAAgB,CAAC,EAAjB,EAApG,CAAb;AACH;;AAEM,EAAA,oBAAoB,CAAC,gBAAD,EAAyB;AAChD,SAAK,oBAAL,GAA4B,gBAA5B;AACA,SAAK,OAAL,CAAa,IAAI,iCAAJ,CAAsC,KAAK,aAA3C,EAA0D,KAAK,oBAA/D,CAAb;AACH;;AAEM,EAAA,eAAe,CAAC,OAAD,EAAiB;AACnC,QAAI,OAAJ,EAAa;AACT,WAAK,UAAL;AACH;AACJ;;AAEM,EAAA,8BAA8B,CAAC,UAAD,EAAmB;AACpD,QAAI,UAAU,KAAK,GAAnB,EAAwB;AACpB,WAAK,OAAL,CAAa,IAAI,qBAAJ,CAA0B,KAAK,SAA/B,EAA0C,KAAK,oBAA/C,CAAb;AACA,WAAK,iBAAL,GAAyB,CAAzB;AACA;AACH,KAJD,MAIO,IAAI,UAAU,KAAK,GAAnB,EAAwB;AAC3B,WAAK,UAAL;AACH;AACJ;;AAEM,EAAA,wBAAwB,CAAC,YAAD,EAAqB;AAChD,UAAM,QAAQ,GAAuB,IAAI,CAAC,KAAL,CAAW,YAAX,CAArC;AACA,SAAK,QAAL,GAAgB,QAAQ,CAAC,KAAT,CAAe,QAA/B;AACH;;AAEM,EAAA,wBAAwB,GAAA;AAC3B,SAAK,UAAL,GAAkB,KAAlB;AACA,SAAK,gBAAL,CAAsB,OAAtB;AACA,SAAK,UAAL;AACH;;AAEM,EAAA,0BAA0B,GAAA;AAC7B,QAAI,CAAC,CAAC,KAAK,gBAAP,IAA2B,CAAC,CAAC,KAAK,UAAtC,EAAkD;AAC9C;AACA,WAAK,gBAAL,CAAsB,MAAtB,CAA6B,gDAA7B,EAF8C,CAG9C;AACA;;AACA,WAAK,gBAAL,CAAsB,OAAtB,CAA8B,IAA9B,GAAqC,KAArC,CAA2C,MAAW,CAAI,CAA1D;AACH;;AACD,SAAK,UAAL,GAAkB,IAAlB;AACA,SAAK,gBAAL,GAAwB,IAAI,QAAJ,EAAxB;AACH;;AAEM,EAAA,oBAAoB,CAAC,IAAD,EAAkB;AACzC,QAAI,KAAK,cAAT,EAAyB;AACrB,WAAK,qBAAL,CAA2B,KAA3B,CAAiC,IAAjC;AACA,WAAK,iBAAL,IAA0B,IAAI,CAAC,UAA/B;;AACA,UAAI,KAAK,wBAAL,KAAkC,SAAtC,EAAiD;AAC7C,aAAK,wBAAL,CAA8B,KAA9B,CAAoC,IAApC;AACH;AACJ;AACJ;;AAEM,EAAA,mBAAmB,CAAC,QAAD,EAA6B;AACnD,SAAK,gBAAL,CAAsB,QAAQ,CAAC,IAAT,CAAc,IAAd,CAAmB,IAAzC,EAA+C,QAAQ,CAAC,IAAxD;AACH;;AAEM,EAAA,wBAAwB,CAAC,QAAD,EAA6B;AACxD,QAAI,QAAQ,CAAC,IAAT,CAAc,cAAd,KAAiC,SAArC,EAAgD;AAC5C,WAAK,0BAAL,IAAmC,QAAQ,CAAC,IAAT,CAAc,cAAjD;AACH;AACJ;;AAEM,EAAA,YAAY,CAAC,QAAD,EAA6B;AAC5C,SAAK,iBAAL,GAAyB,QAAQ,CAAC,IAAT,CAAc,MAAvC;AACH;;AAEM,EAAA,OAAO,GAAA;AACV,QAAI,CAAC,KAAK,cAAV,EAA0B;AACtB;AACA,WAAK,cAAL,GAAsB,IAAtB;AACH;AACJ;;AAEM,EAAA,kBAAkB,GAAA;AACrB,SAAK,UAAL;AACH;AAED;;;AAGG;;;AACI,EAAA,0BAA0B,GAAA;AAC7B,UAAM,SAAS,GAAW,KAAK,0BAA/B;AACA,SAAK,0BAAL,GAAkC,EAAlC;AACA,WAAO,SAAP;AACH;;AAES,EAAA,OAAO,CAAC,KAAD,EAA4B;AACzC,IAAA,MAAM,CAAC,QAAP,CAAgB,OAAhB,CAAwB,KAAxB;AACH;AAED;;;;AAIG;;;AACK,SAAO,QAAP,CAAgB,IAAhB,EAA4B;AAChC,WAAO,IAAI,CAAC,MAAL,IAAe,CAAf,IAAoB,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAhC,IAAuC,IAAI,CAAC,IAAI,CAAC,MAAL,GAAc,CAAf,CAAJ,KAA0B,GAAxE;AACH;;AAEO,EAAA,gBAAgB,CAAC,IAAD,EAAe,IAAf,EAAiC;AACrD,QAAI,IAAI,KAAK,YAAY,CAAC,YAA1B,EAAwC;AACpC,WAAK,cAAL,GAAsB,KAAK,WAAL,CAAiB,OAAjB,CAAyB,IAAzB,EAA+B,KAAK,uBAApC,CAAtB;;AACA,UAAI,KAAK,cAAL,IAAuB,CAA3B,EAA8B;AAC1B,aAAK,uBAAL,GAA+B,KAAK,cAAL,GAAsB,IAAI,CAAC,MAA1D;;AACA,YAAI,KAAK,UAAT,EAAqB;AACjB,cAAI,KAAK,YAAL,CAAkB,KAAK,cAAvB,KAA0C,CAAC,aAAa,CAAC,QAAd,CAAuB,IAAvB,CAA/C,EAA6E;AACzE,iBAAK,gBAAL,CAAsB,IAAtB,EAA4B,IAA5B;AACH;AACJ;AACJ;AACJ,KAVD,MAUO;AACH,WAAK,kBAAL,GAA0B,KAAK,WAAL,CAAiB,OAAjB,CAAyB,IAAzB,EAA+B,KAAK,2BAApC,CAA1B;;AACA,UAAI,KAAK,kBAAL,IAA2B,CAA/B,EAAkC;AAC9B,aAAK,2BAAL,GAAmC,KAAK,kBAAL,GAA0B,IAAI,CAAC,MAAlE;;AACA,YAAI,KAAK,UAAT,EAAqB;AACjB,cAAI,KAAK,YAAL,CAAkB,KAAK,kBAAvB,KAA8C,CAAC,aAAa,CAAC,QAAd,CAAuB,IAAvB,CAAnD,EAAiF;AAC7E,iBAAK,gBAAL,CAAsB,IAAtB,EAA4B,IAA5B;AACH;AACJ;AACJ;AACJ;AACJ;;AAEO,EAAA,UAAU,GAAA;AACd,QAAI,KAAK,kBAAT,EAA6B;AACzB,WAAK,kBAAL,GAA0B,KAA1B;AACA,WAAK,oBAAL,GAA4B,IAA5B;AACA,WAAK,qBAAL,CAA2B,KAA3B;AACA,WAAK,UAAL,GAAkB,KAAlB;;AACA,UAAI,KAAK,wBAAL,KAAkC,SAAtC,EAAiD;AAC7C,aAAK,wBAAL,CAA8B,KAA9B;AACA,aAAK,wBAAL,GAAgC,SAAhC;AACH;AACJ;AACJ;;AAEa,EAAA,sBAAsB,GAAA;;AAChC,UAAI,KAAK,oBAAT,EAA+B;AAC3B,aAAK,iBAAL,GAAyB,IAAI,WAAJ,CAAgB,KAAK,aAArB,CAAzB;;AACA,YAAI;AACA,gBAAM,KAAK,qBAAL,CAA2B,IAA3B,CAAgC,KAAK,iBAArC,CAAN;AACH,SAFD,CAEE,OAAO,CAAP,EAAU;AACR,eAAK,iBAAL,GAAyB,IAAI,WAAJ,CAAgB,CAAhB,CAAzB;AACH;AACJ;AACJ,K;AAAA;AAED;;;;AAIG;;;AACK,EAAA,YAAY,CAAC,GAAD,EAAY;AAC5B,WAAO,KAAK,WAAL,CAAiB,OAAjB,CAAyB,GAAzB,EAA8B,GAAG,GAAG,CAApC,IAAyC,KAAK,WAAL,CAAiB,OAAjB,CAAyB,GAAzB,EAA8B,GAAG,GAAG,CAApC,CAAhD;AACH;;AAjSqB","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    createNoDashGuid,\r\n    Deferred,\r\n    Events,\r\n    IAudioDestination\r\n} from \"../common/Exports\";\r\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat\";\r\nimport { PullAudioOutputStreamImpl } from \"../sdk/Audio/AudioOutputStream\";\r\nimport { ISynthesisMetadata, MetadataType } from \"./ServiceMessages/SynthesisAudioMetadata\";\r\nimport { SynthesisAdapterBase } from \"./SynthesisAdapterBase\";\r\nimport {\r\n    ConnectingToSynthesisServiceEvent,\r\n    SpeechSynthesisEvent,\r\n    SynthesisStartedEvent,\r\n    SynthesisTriggeredEvent,\r\n} from \"./SynthesisEvents\";\r\n\r\nexport interface ISynthesisResponseContext {\r\n    serviceTag: string;\r\n}\r\n\r\nexport interface ISynthesisResponseAudio {\r\n    type: string;\r\n    streamId: string;\r\n}\r\n\r\nexport interface ISynthesisResponse {\r\n    context: ISynthesisResponseContext;\r\n    audio: ISynthesisResponseAudio;\r\n}\r\n\r\nexport class SynthesisTurn {\r\n\r\n    public get requestId(): string {\r\n        return this.privRequestId;\r\n    }\r\n\r\n    public get streamId(): string {\r\n        return this.privStreamId;\r\n    }\r\n\r\n    public set streamId(value: string) {\r\n        this.privStreamId = value;\r\n    }\r\n\r\n    public get audioOutputFormat(): AudioOutputFormatImpl {\r\n        return this.privAudioOutputFormat;\r\n    }\r\n\r\n    public set audioOutputFormat(format: AudioOutputFormatImpl) {\r\n        this.privAudioOutputFormat = format;\r\n    }\r\n\r\n    public get turnCompletionPromise(): Promise<void> {\r\n        return this.privTurnDeferral.promise;\r\n    }\r\n\r\n    public get isSynthesisEnded(): boolean {\r\n        return this.privIsSynthesisEnded;\r\n    }\r\n\r\n    public get isSynthesizing(): boolean {\r\n        return this.privIsSynthesizing;\r\n    }\r\n\r\n    public get currentTextOffset(): number {\r\n        return this.privTextOffset;\r\n    }\r\n\r\n    public get currentSentenceOffset(): number {\r\n        return this.privSentenceOffset;\r\n    }\r\n\r\n    // The number of bytes received for current turn\r\n    public get bytesReceived(): number {\r\n        return this.privBytesReceived;\r\n    }\r\n\r\n    public get audioDuration(): number {\r\n        return this.privAudioDuration;\r\n    }\r\n\r\n    private privIsDisposed: boolean = false;\r\n    private privAuthFetchEventId: string;\r\n    private privIsSynthesizing: boolean = false;\r\n    private privIsSynthesisEnded: boolean = false;\r\n    private privBytesReceived: number = 0;\r\n    private privRequestId: string;\r\n    private privStreamId: string;\r\n    private privTurnDeferral: Deferred<void>;\r\n    private privInTurn: boolean = false;\r\n    private privAudioOutputFormat: AudioOutputFormatImpl;\r\n    private privAudioOutputStream: PullAudioOutputStreamImpl;\r\n    private privReceivedAudio: ArrayBuffer;\r\n    private privReceivedAudioWithHeader: ArrayBuffer;\r\n    private privTextOffset: number = 0;\r\n    private privNextSearchTextIndex: number = 0;\r\n    private privSentenceOffset: number = 0;\r\n    private privNextSearchSentenceIndex: number = 0;\r\n    private privPartialVisemeAnimation: string;\r\n    private privRawText: string;\r\n    private privIsSSML: boolean;\r\n    private privTurnAudioDestination: IAudioDestination;\r\n    private privAudioDuration: number;\r\n\r\n    public constructor() {\r\n        this.privRequestId = createNoDashGuid();\r\n        this.privTurnDeferral = new Deferred<void>();\r\n\r\n        // We're not in a turn, so resolve.\r\n        this.privTurnDeferral.resolve();\r\n    }\r\n\r\n    public async getAllReceivedAudio(): Promise<ArrayBuffer> {\r\n        if (!!this.privReceivedAudio) {\r\n            return Promise.resolve(this.privReceivedAudio);\r\n        }\r\n        if (!this.privIsSynthesisEnded) {\r\n            return null;\r\n        }\r\n        await this.readAllAudioFromStream();\r\n        return Promise.resolve(this.privReceivedAudio);\r\n    }\r\n\r\n    public async getAllReceivedAudioWithHeader(): Promise<ArrayBuffer> {\r\n        if (!!this.privReceivedAudioWithHeader) {\r\n            return this.privReceivedAudioWithHeader;\r\n        }\r\n        if (!this.privIsSynthesisEnded) {\r\n            return null;\r\n        }\r\n        if (this.audioOutputFormat.hasHeader) {\r\n            const audio: ArrayBuffer = await this.getAllReceivedAudio();\r\n            this.privReceivedAudioWithHeader = SynthesisAdapterBase.addHeader(audio, this.audioOutputFormat);\r\n            return this.privReceivedAudioWithHeader;\r\n        } else {\r\n            return this.getAllReceivedAudio();\r\n        }\r\n    }\r\n\r\n    public startNewSynthesis(requestId: string, rawText: string, isSSML: boolean, audioDestination?: IAudioDestination): void {\r\n        this.privIsSynthesisEnded = false;\r\n        this.privIsSynthesizing = true;\r\n        this.privRequestId = requestId;\r\n        this.privRawText = rawText;\r\n        this.privIsSSML = isSSML;\r\n        this.privAudioOutputStream = new PullAudioOutputStreamImpl();\r\n        this.privAudioOutputStream.format = this.privAudioOutputFormat;\r\n        this.privReceivedAudio = null;\r\n        this.privReceivedAudioWithHeader = null;\r\n        this.privBytesReceived = 0;\r\n        this.privTextOffset = 0;\r\n        this.privNextSearchTextIndex = 0;\r\n        this.privSentenceOffset = 0;\r\n        this.privNextSearchSentenceIndex = 0;\r\n        this.privPartialVisemeAnimation = \"\";\r\n        if (audioDestination !== undefined) {\r\n            this.privTurnAudioDestination = audioDestination;\r\n            this.privTurnAudioDestination.format = this.privAudioOutputFormat;\r\n        }\r\n        this.onEvent(new SynthesisTriggeredEvent(this.requestId, undefined, audioDestination === undefined ? undefined : audioDestination.id()));\r\n    }\r\n\r\n    public onPreConnectionStart(authFetchEventId: string): void {\r\n        this.privAuthFetchEventId = authFetchEventId;\r\n        this.onEvent(new ConnectingToSynthesisServiceEvent(this.privRequestId, this.privAuthFetchEventId));\r\n    }\r\n\r\n    public onAuthCompleted(isError: boolean): void {\r\n        if (isError) {\r\n            this.onComplete();\r\n        }\r\n    }\r\n\r\n    public onConnectionEstablishCompleted(statusCode: number): void {\r\n        if (statusCode === 200) {\r\n            this.onEvent(new SynthesisStartedEvent(this.requestId, this.privAuthFetchEventId));\r\n            this.privBytesReceived = 0;\r\n            return;\r\n        } else if (statusCode === 403) {\r\n            this.onComplete();\r\n        }\r\n    }\r\n\r\n    public onServiceResponseMessage(responseJson: string): void {\r\n        const response: ISynthesisResponse = JSON.parse(responseJson) as ISynthesisResponse;\r\n        this.streamId = response.audio.streamId;\r\n    }\r\n\r\n    public onServiceTurnEndResponse(): void {\r\n        this.privInTurn = false;\r\n        this.privTurnDeferral.resolve();\r\n        this.onComplete();\r\n    }\r\n\r\n    public onServiceTurnStartResponse(): void {\r\n        if (!!this.privTurnDeferral && !!this.privInTurn) {\r\n            // What? How are we starting a turn with another not done?\r\n            this.privTurnDeferral.reject(\"Another turn started before current completed.\");\r\n            // Avoid UnhandledPromiseRejection if privTurnDeferral is not being awaited\r\n            // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n            this.privTurnDeferral.promise.then().catch((): void => { });\r\n        }\r\n        this.privInTurn = true;\r\n        this.privTurnDeferral = new Deferred<void>();\r\n    }\r\n\r\n    public onAudioChunkReceived(data: ArrayBuffer): void {\r\n        if (this.isSynthesizing) {\r\n            this.privAudioOutputStream.write(data);\r\n            this.privBytesReceived += data.byteLength;\r\n            if (this.privTurnAudioDestination !== undefined) {\r\n                this.privTurnAudioDestination.write(data);\r\n            }\r\n        }\r\n    }\r\n\r\n    public onTextBoundaryEvent(metadata: ISynthesisMetadata): void {\r\n        this.updateTextOffset(metadata.Data.text.Text, metadata.Type);\r\n    }\r\n\r\n    public onVisemeMetadataReceived(metadata: ISynthesisMetadata): void {\r\n        if (metadata.Data.AnimationChunk !== undefined) {\r\n            this.privPartialVisemeAnimation += metadata.Data.AnimationChunk;\r\n        }\r\n    }\r\n\r\n    public onSessionEnd(metadata: ISynthesisMetadata): void {\r\n        this.privAudioDuration = metadata.Data.Offset;\r\n    }\r\n\r\n    public dispose(): void {\r\n        if (!this.privIsDisposed) {\r\n            // we should have completed by now. If we did not its an unknown error.\r\n            this.privIsDisposed = true;\r\n        }\r\n    }\r\n\r\n    public onStopSynthesizing(): void {\r\n        this.onComplete();\r\n    }\r\n\r\n    /**\r\n     * Gets the viseme animation string (merged from animation chunk), and clears the internal\r\n     * partial animation.\r\n     */\r\n    public getAndClearVisemeAnimation(): string {\r\n        const animation: string = this.privPartialVisemeAnimation;\r\n        this.privPartialVisemeAnimation = \"\";\r\n        return animation;\r\n    }\r\n\r\n    protected onEvent(event: SpeechSynthesisEvent): void {\r\n        Events.instance.onEvent(event);\r\n    }\r\n\r\n    /**\r\n     * Check if the text is an XML(SSML) tag\r\n     * @param text\r\n     * @private\r\n     */\r\n    private static isXmlTag(text: string): boolean {\r\n        return text.length >= 2 && text[0] === \"<\" && text[text.length - 1] === \">\";\r\n    }\r\n\r\n    private updateTextOffset(text: string, type: MetadataType): void {\r\n        if (type === MetadataType.WordBoundary) {\r\n            this.privTextOffset = this.privRawText.indexOf(text, this.privNextSearchTextIndex);\r\n            if (this.privTextOffset >= 0) {\r\n                this.privNextSearchTextIndex = this.privTextOffset + text.length;\r\n                if (this.privIsSSML) {\r\n                    if (this.withinXmlTag(this.privTextOffset) && !SynthesisTurn.isXmlTag(text)) {\r\n                        this.updateTextOffset(text, type);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            this.privSentenceOffset = this.privRawText.indexOf(text, this.privNextSearchSentenceIndex);\r\n            if (this.privSentenceOffset >= 0) {\r\n                this.privNextSearchSentenceIndex = this.privSentenceOffset + text.length;\r\n                if (this.privIsSSML) {\r\n                    if (this.withinXmlTag(this.privSentenceOffset) && !SynthesisTurn.isXmlTag(text)) {\r\n                        this.updateTextOffset(text, type);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private onComplete(): void {\r\n        if (this.privIsSynthesizing) {\r\n            this.privIsSynthesizing = false;\r\n            this.privIsSynthesisEnded = true;\r\n            this.privAudioOutputStream.close();\r\n            this.privInTurn = false;\r\n            if (this.privTurnAudioDestination !== undefined) {\r\n                this.privTurnAudioDestination.close();\r\n                this.privTurnAudioDestination = undefined;\r\n            }\r\n        }\r\n    }\r\n\r\n    private async readAllAudioFromStream(): Promise<void> {\r\n        if (this.privIsSynthesisEnded) {\r\n            this.privReceivedAudio = new ArrayBuffer(this.bytesReceived);\r\n            try {\r\n                await this.privAudioOutputStream.read(this.privReceivedAudio);\r\n            } catch (e) {\r\n                this.privReceivedAudio = new ArrayBuffer(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if current idx is in XML(SSML) tag\r\n     * @param idx\r\n     * @private\r\n     */\r\n    private withinXmlTag(idx: number): boolean {\r\n        return this.privRawText.indexOf(\"<\", idx + 1) > this.privRawText.indexOf(\">\", idx + 1);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}