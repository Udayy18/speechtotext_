{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { RiffPcmEncoder } from \"../common/Exports\";\nexport class PcmRecorder {\n  constructor(stopInputOnRelease) {\n    this.privStopInputOnRelease = stopInputOnRelease;\n  }\n\n  record(context, mediaStream, outputStream) {\n    const desiredSampleRate = 16000;\n    const waveStreamEncoder = new RiffPcmEncoder(context.sampleRate, desiredSampleRate);\n    const micInput = context.createMediaStreamSource(mediaStream);\n\n    if (!this.privSpeechProcessorScript) {\n      const workletScript = `class SP extends AudioWorkletProcessor {\n                constructor(options) {\n                  super(options);\n                }\n                process(inputs, outputs) {\n                  const input = inputs[0];\n                  const output = [];\n                  for (let channel = 0; channel < input.length; channel += 1) {\n                    output[channel] = input[channel];\n                  }\n                  this.port.postMessage(output[0]);\n                  return true;\n                }\n              }\n              registerProcessor('speech-processor', SP);`;\n      const blob = new Blob([workletScript], {\n        type: \"application/javascript; charset=utf-8\"\n      });\n      this.privSpeechProcessorScript = URL.createObjectURL(blob);\n    }\n\n    const attachScriptProcessor = () => {\n      // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n      const scriptNode = (() => {\n        let bufferSize = 0;\n\n        try {\n          return context.createScriptProcessor(bufferSize, 1, 1);\n        } catch (error) {\n          // Webkit (<= version 31) requires a valid bufferSize.\n          bufferSize = 2048;\n          let audioSampleRate = context.sampleRate;\n\n          while (bufferSize < 16384 && audioSampleRate >= 2 * desiredSampleRate) {\n            bufferSize <<= 1;\n            audioSampleRate >>= 1;\n          }\n\n          return context.createScriptProcessor(bufferSize, 1, 1);\n        }\n      })();\n\n      scriptNode.onaudioprocess = event => {\n        const inputFrame = event.inputBuffer.getChannelData(0);\n\n        if (outputStream && !outputStream.isClosed) {\n          const waveFrame = waveStreamEncoder.encode(inputFrame);\n\n          if (!!waveFrame) {\n            outputStream.writeStreamChunk({\n              buffer: waveFrame,\n              isEnd: false,\n              timeReceived: Date.now()\n            });\n          }\n        }\n      };\n\n      micInput.connect(scriptNode);\n      scriptNode.connect(context.destination);\n      this.privMediaResources = {\n        scriptProcessorNode: scriptNode,\n        source: micInput,\n        stream: mediaStream\n      };\n    }; // https://webaudio.github.io/web-audio-api/#audioworklet\n    // Using AudioWorklet to improve audio quality and avoid audio glitches due to blocking the UI thread\n\n\n    if (!!this.privSpeechProcessorScript && !!context.audioWorklet) {\n      context.audioWorklet.addModule(this.privSpeechProcessorScript).then(() => {\n        const workletNode = new AudioWorkletNode(context, \"speech-processor\");\n\n        workletNode.port.onmessage = ev => {\n          const inputFrame = ev.data;\n\n          if (outputStream && !outputStream.isClosed) {\n            const waveFrame = waveStreamEncoder.encode(inputFrame);\n\n            if (!!waveFrame) {\n              outputStream.writeStreamChunk({\n                buffer: waveFrame,\n                isEnd: false,\n                timeReceived: Date.now()\n              });\n            }\n          }\n        };\n\n        micInput.connect(workletNode);\n        workletNode.connect(context.destination);\n        this.privMediaResources = {\n          scriptProcessorNode: workletNode,\n          source: micInput,\n          stream: mediaStream\n        };\n      }).catch(() => {\n        attachScriptProcessor();\n      });\n    } else {\n      try {\n        attachScriptProcessor();\n      } catch (err) {\n        throw new Error(`Unable to start audio worklet node for PCMRecorder: ${err}`);\n      }\n    }\n  }\n\n  releaseMediaResources(context) {\n    if (this.privMediaResources) {\n      if (this.privMediaResources.scriptProcessorNode) {\n        this.privMediaResources.scriptProcessorNode.disconnect(context.destination);\n        this.privMediaResources.scriptProcessorNode = null;\n      }\n\n      if (this.privMediaResources.source) {\n        this.privMediaResources.source.disconnect();\n\n        if (this.privStopInputOnRelease) {\n          this.privMediaResources.stream.getTracks().forEach(track => track.stop());\n        }\n\n        this.privMediaResources.source = null;\n      }\n    }\n  }\n\n  setWorkletUrl(url) {\n    this.privSpeechProcessorScript = url;\n  }\n\n}","map":{"version":3,"sources":["src/common.browser/PCMRecorder.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { RiffPcmEncoder, Stream } from \"../common/Exports\";\r\nimport { IRecorder } from \"./IRecorder\";\r\n\r\nexport class PcmRecorder implements IRecorder {\r\n    private privMediaResources: IMediaResources;\r\n    private privSpeechProcessorScript: string; // speech-processor.js Url\r\n    private privStopInputOnRelease: boolean;\r\n\r\n    public constructor(stopInputOnRelease: boolean) {\r\n        this.privStopInputOnRelease = stopInputOnRelease;\r\n    }\r\n\r\n    public record(context: AudioContext, mediaStream: MediaStream, outputStream: Stream<ArrayBuffer>): void {\r\n        const desiredSampleRate = 16000;\r\n\r\n        const waveStreamEncoder = new RiffPcmEncoder(context.sampleRate, desiredSampleRate);\r\n\r\n        const micInput = context.createMediaStreamSource(mediaStream);\r\n        if (!this.privSpeechProcessorScript) {\r\n            const workletScript = `class SP extends AudioWorkletProcessor {\r\n                constructor(options) {\r\n                  super(options);\r\n                }\r\n                process(inputs, outputs) {\r\n                  const input = inputs[0];\r\n                  const output = [];\r\n                  for (let channel = 0; channel < input.length; channel += 1) {\r\n                    output[channel] = input[channel];\r\n                  }\r\n                  this.port.postMessage(output[0]);\r\n                  return true;\r\n                }\r\n              }\r\n              registerProcessor('speech-processor', SP);`;\r\n            const blob = new Blob([workletScript], { type: \"application/javascript; charset=utf-8\" });\r\n            this.privSpeechProcessorScript = URL.createObjectURL(blob);\r\n        }\r\n\r\n        const attachScriptProcessor = (): void => {\r\n            // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\r\n            const scriptNode = (() => {\r\n                let bufferSize = 0;\r\n                try {\r\n                    return context.createScriptProcessor(bufferSize, 1, 1);\r\n                } catch (error) {\r\n                    // Webkit (<= version 31) requires a valid bufferSize.\r\n                    bufferSize = 2048;\r\n                    let audioSampleRate = context.sampleRate;\r\n                    while (bufferSize < 16384 && audioSampleRate >= (2 * desiredSampleRate)) {\r\n                        bufferSize <<= 1;\r\n                        audioSampleRate >>= 1;\r\n                    }\r\n                    return context.createScriptProcessor(bufferSize, 1, 1);\r\n                }\r\n            })();\r\n            scriptNode.onaudioprocess = (event: AudioProcessingEvent): void => {\r\n                const inputFrame = event.inputBuffer.getChannelData(0);\r\n\r\n                if (outputStream && !outputStream.isClosed) {\r\n                    const waveFrame = waveStreamEncoder.encode(inputFrame);\r\n                    if (!!waveFrame) {\r\n                        outputStream.writeStreamChunk({\r\n                            buffer: waveFrame,\r\n                            isEnd: false,\r\n                            timeReceived: Date.now(),\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n            micInput.connect(scriptNode);\r\n            scriptNode.connect(context.destination);\r\n            this.privMediaResources = {\r\n                scriptProcessorNode: scriptNode,\r\n                source: micInput,\r\n                stream: mediaStream,\r\n            };\r\n        };\r\n\r\n        // https://webaudio.github.io/web-audio-api/#audioworklet\r\n        // Using AudioWorklet to improve audio quality and avoid audio glitches due to blocking the UI thread\r\n\r\n        if (!!this.privSpeechProcessorScript && !!context.audioWorklet) {\r\n            context.audioWorklet\r\n                .addModule(this.privSpeechProcessorScript)\r\n                .then((): void => {\r\n                    const workletNode = new AudioWorkletNode(context, \"speech-processor\");\r\n                    workletNode.port.onmessage = (ev: MessageEvent): void => {\r\n                        const inputFrame: Float32Array = ev.data as Float32Array;\r\n\r\n                        if (outputStream && !outputStream.isClosed) {\r\n                            const waveFrame = waveStreamEncoder.encode(inputFrame);\r\n                            if (!!waveFrame) {\r\n                                outputStream.writeStreamChunk({\r\n                                    buffer: waveFrame,\r\n                                    isEnd: false,\r\n                                    timeReceived: Date.now(),\r\n                                });\r\n                            }\r\n                        }\r\n                    };\r\n                    micInput.connect(workletNode);\r\n                    workletNode.connect(context.destination);\r\n                    this.privMediaResources = {\r\n                        scriptProcessorNode: workletNode,\r\n                        source: micInput,\r\n                        stream: mediaStream,\r\n                    };\r\n                })\r\n                .catch((): void => {\r\n                    attachScriptProcessor();\r\n                });\r\n        } else {\r\n            try {\r\n                attachScriptProcessor();\r\n            } catch (err) {\r\n                throw new Error(`Unable to start audio worklet node for PCMRecorder: ${err as string}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    public releaseMediaResources(context: AudioContext): void {\r\n        if (this.privMediaResources) {\r\n            if (this.privMediaResources.scriptProcessorNode) {\r\n                this.privMediaResources.scriptProcessorNode.disconnect(context.destination);\r\n                this.privMediaResources.scriptProcessorNode = null;\r\n            }\r\n            if (this.privMediaResources.source) {\r\n                this.privMediaResources.source.disconnect();\r\n                if (this.privStopInputOnRelease) {\r\n                    this.privMediaResources.stream.getTracks().forEach((track: MediaStreamTrack): void => track.stop());\r\n                }\r\n                this.privMediaResources.source = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    public setWorkletUrl(url: string): void {\r\n        this.privSpeechProcessorScript = url;\r\n    }\r\n}\r\n\r\ninterface IMediaResources {\r\n    source: MediaStreamAudioSourceNode;\r\n    scriptProcessorNode: ScriptProcessorNode | AudioWorkletNode;\r\n    stream: MediaStream;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}