{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport bent from \"bent\";\nimport { ArgumentNullError, Deferred } from \"../common/Exports\";\nexport var RestRequestType;\n\n(function (RestRequestType) {\n  RestRequestType[\"Get\"] = \"GET\";\n  RestRequestType[\"Post\"] = \"POST\";\n  RestRequestType[\"Delete\"] = \"DELETE\";\n  RestRequestType[\"File\"] = \"file\";\n})(RestRequestType || (RestRequestType = {})); // accept rest operations via request method and return abstracted objects from server response\n\n\nexport class RestMessageAdapter {\n  constructor(configParams) {\n    if (!configParams) {\n      throw new ArgumentNullError(\"configParams\");\n    }\n\n    this.privHeaders = configParams.headers;\n    this.privIgnoreCache = configParams.ignoreCache;\n  }\n\n  static extractHeaderValue(headerKey, headers) {\n    let headerValue = \"\";\n\n    try {\n      const arr = headers.trim().split(/[\\r\\n]+/);\n      const headerMap = {};\n      arr.forEach(line => {\n        const parts = line.split(\": \");\n        const header = parts.shift().toLowerCase();\n        const value = parts.join(\": \");\n        headerMap[header] = value;\n      });\n      headerValue = headerMap[headerKey.toLowerCase()];\n    } catch (e) {// ignore the error\n    }\n\n    return headerValue;\n  }\n\n  set options(configParams) {\n    this.privHeaders = configParams.headers;\n    this.privIgnoreCache = configParams.ignoreCache;\n  }\n\n  setHeaders(key, value) {\n    this.privHeaders[key] = value;\n  }\n\n  request(method, uri, queryParams = {}, body = null, binaryBody = null) {\n    const responseReceivedDeferral = new Deferred();\n    const requestCommand = method === RestRequestType.File ? \"POST\" : method;\n\n    const handleRestResponse = (data, j = {}) => {\n      const d = data;\n      return {\n        data: JSON.stringify(j),\n        headers: JSON.stringify(data.headers),\n        json: j,\n        ok: data.statusCode >= 200 && data.statusCode < 300,\n        status: data.statusCode,\n        statusText: j.error ? j.error.message : d.statusText ? d.statusText : d.statusMessage\n      };\n    };\n\n    const blobToArrayBuffer = blob => {\n      const reader = new FileReader();\n      reader.readAsArrayBuffer(blob);\n      return new Promise(resolve => {\n        reader.onloadend = () => {\n          resolve(reader.result);\n        };\n      });\n    };\n\n    const send = postData => {\n      const sendRequest = bent(uri, requestCommand, this.privHeaders, 200, 201, 202, 204, 400, 401, 402, 403, 404);\n      const params = this.queryParams(queryParams) === \"\" ? \"\" : `?${this.queryParams(queryParams)}`;\n      sendRequest(params, postData).then(data => __awaiter(this, void 0, void 0, function* () {\n        if (method === RestRequestType.Delete || data.statusCode === 204) {\n          // No JSON from Delete and reset (204) operations\n          responseReceivedDeferral.resolve(handleRestResponse(data));\n        } else {\n          try {\n            const j = yield data.json();\n            responseReceivedDeferral.resolve(handleRestResponse(data, j));\n          } catch (_a) {\n            responseReceivedDeferral.resolve(handleRestResponse(data));\n          }\n        }\n      })).catch(error => {\n        responseReceivedDeferral.reject(error);\n      });\n    };\n\n    if (this.privIgnoreCache) {\n      this.privHeaders[\"Cache-Control\"] = \"no-cache\";\n    }\n\n    if (method === RestRequestType.File && binaryBody) {\n      const contentType = \"multipart/form-data\";\n      this.privHeaders[\"content-type\"] = contentType;\n      this.privHeaders[\"Content-Type\"] = contentType;\n\n      if (typeof Blob !== \"undefined\" && binaryBody instanceof Blob) {\n        blobToArrayBuffer(binaryBody).then(res => {\n          send(res);\n        }).catch(error => {\n          responseReceivedDeferral.reject(error);\n        });\n      } else {\n        send(binaryBody);\n      }\n    } else {\n      if (method === RestRequestType.Post && body) {\n        this.privHeaders[\"content-type\"] = \"application/json\";\n        this.privHeaders[\"Content-Type\"] = \"application/json\";\n      }\n\n      send(body);\n    }\n\n    return responseReceivedDeferral.promise;\n  }\n\n  withQuery(url, params = {}) {\n    const queryString = this.queryParams(params);\n    return queryString ? url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + queryString : url;\n  }\n\n  queryParams(params = {}) {\n    return Object.keys(params).map(k => encodeURIComponent(k) + \"=\" + encodeURIComponent(params[k])).join(\"&\");\n  }\n\n}","map":{"version":3,"sources":["src/common.browser/RestMessageAdapter.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport bent, { BentResponse } from \"bent\";\r\nimport {\r\n    ArgumentNullError,\r\n    Deferred\r\n} from \"../common/Exports\";\r\nimport { IRequestOptions } from \"./Exports\";\r\n\r\nexport enum RestRequestType {\r\n    Get = \"GET\",\r\n    Post = \"POST\",\r\n    Delete = \"DELETE\",\r\n    File = \"file\",\r\n}\r\n\r\nexport interface IRestResponse {\r\n    ok: boolean;\r\n    status: number;\r\n    statusText: string;\r\n    data: string;\r\n    json: any;\r\n    headers: string;\r\n}\r\n\r\ninterface JsonError {\r\n    error?: {\r\n        message: string;\r\n    };\r\n}\r\n\r\n// accept rest operations via request method and return abstracted objects from server response\r\nexport class RestMessageAdapter {\r\n\r\n    private privIgnoreCache: boolean;\r\n    private privHeaders: { [key: string]: string };\r\n\r\n    public constructor(\r\n        configParams: IRequestOptions\r\n        ) {\r\n\r\n        if (!configParams) {\r\n            throw new ArgumentNullError(\"configParams\");\r\n        }\r\n\r\n        this.privHeaders = configParams.headers;\r\n        this.privIgnoreCache = configParams.ignoreCache;\r\n    }\r\n\r\n    public static extractHeaderValue(headerKey: string, headers: string): string {\r\n        let headerValue: string = \"\";\r\n\r\n        try {\r\n            const arr = headers.trim().split(/[\\r\\n]+/);\r\n            const headerMap: { [key: string]: string } = {};\r\n            arr.forEach((line: string): void => {\r\n                const parts = line.split(\": \");\r\n                const header = parts.shift().toLowerCase();\r\n                const value = parts.join(\": \");\r\n                headerMap[header] = value;\r\n            });\r\n\r\n            headerValue = headerMap[headerKey.toLowerCase()];\r\n        } catch (e) {\r\n            // ignore the error\r\n        }\r\n\r\n        return headerValue;\r\n    }\r\n\r\n    public set options(configParams: IRequestOptions) {\r\n        this.privHeaders = configParams.headers;\r\n        this.privIgnoreCache = configParams.ignoreCache;\r\n    }\r\n\r\n    public setHeaders(key: string, value: string): void {\r\n        this.privHeaders[key] = value;\r\n    }\r\n\r\n    public request(\r\n        method: RestRequestType,\r\n        uri: string,\r\n        queryParams: { [key: string]: any } = {},\r\n        body: bent.RequestBody = null,\r\n        binaryBody: Blob | Buffer = null,\r\n        ): Promise<IRestResponse> {\r\n\r\n        const responseReceivedDeferral = new Deferred<IRestResponse>();\r\n\r\n        const requestCommand = method === RestRequestType.File ? \"POST\" : method;\r\n        const handleRestResponse = (data: BentResponse, j: JsonError = {}): IRestResponse => {\r\n            const d: { statusText?: string; statusMessage?: string } = data;\r\n            return {\r\n                data: JSON.stringify(j),\r\n                headers: JSON.stringify(data.headers),\r\n                json: j,\r\n                ok: data.statusCode >= 200 && data.statusCode < 300,\r\n                status: data.statusCode,\r\n                statusText: j.error ? j.error.message : d.statusText ? d.statusText : d.statusMessage\r\n            };\r\n        };\r\n\r\n        const blobToArrayBuffer = (blob: Blob): Promise<unknown> => {\r\n            const reader = new FileReader();\r\n            reader.readAsArrayBuffer(blob);\r\n            return new Promise((resolve: (value: unknown) => void): void => {\r\n                reader.onloadend = (): void => {\r\n                resolve(reader.result);\r\n                };\r\n            });\r\n        };\r\n\r\n        const send = (postData: bent.RequestBody): void => {\r\n            const sendRequest = bent(uri, requestCommand, this.privHeaders, 200, 201, 202, 204, 400, 401, 402, 403, 404);\r\n            const params = this.queryParams(queryParams) === \"\" ? \"\" : `?${this.queryParams(queryParams)}`;\r\n            sendRequest(params, postData).then( async (data: BentResponse): Promise<void> => {\r\n                if (method === RestRequestType.Delete || data.statusCode === 204) {\r\n                    // No JSON from Delete and reset (204) operations\r\n                    responseReceivedDeferral.resolve(handleRestResponse(data));\r\n                } else {\r\n                    try {\r\n                        const j: JsonError = await data.json() as JsonError;\r\n                        responseReceivedDeferral.resolve(handleRestResponse(data, j));\r\n                    } catch {\r\n                        responseReceivedDeferral.resolve(handleRestResponse(data));\r\n                    }\r\n                }\r\n            }).catch((error: string): void => {\r\n                responseReceivedDeferral.reject(error);\r\n            });\r\n        };\r\n\r\n        if (this.privIgnoreCache) {\r\n            this.privHeaders[\"Cache-Control\"] = \"no-cache\";\r\n        }\r\n\r\n        if (method === RestRequestType.File && binaryBody) {\r\n            const contentType = \"multipart/form-data\";\r\n            this.privHeaders[\"content-type\"] = contentType;\r\n            this.privHeaders[\"Content-Type\"] = contentType;\r\n            if (typeof (Blob) !== \"undefined\" && binaryBody instanceof Blob) {\r\n                blobToArrayBuffer(binaryBody).then( (res: bent.RequestBody): void => {\r\n                    send(res);\r\n                }).catch((error: any): void => {\r\n                    responseReceivedDeferral.reject(error as string);\r\n                });\r\n            } else {\r\n                send(binaryBody as Buffer);\r\n            }\r\n        } else {\r\n            if (method === RestRequestType.Post && body) {\r\n                this.privHeaders[\"content-type\"] = \"application/json\";\r\n                this.privHeaders[\"Content-Type\"] = \"application/json\";\r\n            }\r\n            send(body);\r\n        }\r\n        return responseReceivedDeferral.promise;\r\n    }\r\n\r\n    private withQuery(url: string, params: { [key: string]: string } = {}): any {\r\n        const queryString = this.queryParams(params);\r\n        return queryString ? url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + queryString : url;\r\n    }\r\n\r\n    private queryParams(params: { [key: string]: string } = {}): string {\r\n        return Object.keys(params)\r\n            .map((k: string): string => encodeURIComponent(k) + \"=\" + encodeURIComponent(params[k]))\r\n            .join(\"&\");\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}