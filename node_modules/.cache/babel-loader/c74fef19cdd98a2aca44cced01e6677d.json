{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nexport class RiffPcmEncoder {\n  constructor(actualSampleRate, desiredSampleRate) {\n    this.privActualSampleRate = actualSampleRate;\n    this.privDesiredSampleRate = desiredSampleRate;\n  }\n\n  encode(actualAudioFrame) {\n    const audioFrame = this.downSampleAudioFrame(actualAudioFrame, this.privActualSampleRate, this.privDesiredSampleRate);\n\n    if (!audioFrame) {\n      return null;\n    }\n\n    const audioLength = audioFrame.length * 2;\n    const buffer = new ArrayBuffer(audioLength);\n    const view = new DataView(buffer);\n    this.floatTo16BitPCM(view, 0, audioFrame);\n    return buffer;\n  }\n\n  setString(view, offset, str) {\n    for (let i = 0; i < str.length; i++) {\n      view.setUint8(offset + i, str.charCodeAt(i));\n    }\n  }\n\n  floatTo16BitPCM(view, offset, input) {\n    for (let i = 0; i < input.length; i++, offset += 2) {\n      const s = Math.max(-1, Math.min(1, input[i]));\n      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);\n    }\n  }\n\n  downSampleAudioFrame(srcFrame, srcRate, dstRate) {\n    if (!srcFrame) {\n      return null;\n    }\n\n    if (dstRate === srcRate || dstRate > srcRate) {\n      return srcFrame;\n    }\n\n    const ratio = srcRate / dstRate;\n    const dstLength = Math.round(srcFrame.length / ratio);\n    const dstFrame = new Float32Array(dstLength);\n    let srcOffset = 0;\n    let dstOffset = 0;\n\n    while (dstOffset < dstLength) {\n      const nextSrcOffset = Math.round((dstOffset + 1) * ratio);\n      let accum = 0;\n      let count = 0;\n\n      while (srcOffset < nextSrcOffset && srcOffset < srcFrame.length) {\n        accum += srcFrame[srcOffset++];\n        count++;\n      }\n\n      dstFrame[dstOffset++] = accum / count;\n    }\n\n    return dstFrame;\n  }\n\n}","map":{"version":3,"sources":["src/common/RiffPcmEncoder.ts"],"names":[],"mappings":"AAAA;AACA;AAEA,OAAM,MAAO,cAAP,CAAqB;AAKvB,EAAA,WAAA,CAAmB,gBAAnB,EAA6C,iBAA7C,EAAsE;AAClE,SAAK,oBAAL,GAA4B,gBAA5B;AACA,SAAK,qBAAL,GAA6B,iBAA7B;AACH;;AAEM,EAAA,MAAM,CAAC,gBAAD,EAA+B;AAExC,UAAM,UAAU,GAAG,KAAK,oBAAL,CAA0B,gBAA1B,EAA4C,KAAK,oBAAjD,EAAuE,KAAK,qBAA5E,CAAnB;;AAEA,QAAI,CAAC,UAAL,EAAiB;AACb,aAAO,IAAP;AACH;;AAED,UAAM,WAAW,GAAG,UAAU,CAAC,MAAX,GAAoB,CAAxC;AAEA,UAAM,MAAM,GAAG,IAAI,WAAJ,CAAgB,WAAhB,CAAf;AACA,UAAM,IAAI,GAAG,IAAI,QAAJ,CAAa,MAAb,CAAb;AACA,SAAK,eAAL,CAAqB,IAArB,EAA2B,CAA3B,EAA8B,UAA9B;AAEA,WAAO,MAAP;AACH;;AAEO,EAAA,SAAS,CAAC,IAAD,EAAiB,MAAjB,EAAiC,GAAjC,EAA4C;AACzD,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAAG,CAAC,MAAxB,EAAgC,CAAC,EAAjC,EAAqC;AACjC,MAAA,IAAI,CAAC,QAAL,CAAc,MAAM,GAAG,CAAvB,EAA0B,GAAG,CAAC,UAAJ,CAAe,CAAf,CAA1B;AACH;AACJ;;AAEO,EAAA,eAAe,CAAC,IAAD,EAAiB,MAAjB,EAAiC,KAAjC,EAAoD;AACvE,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,IAAK,MAAM,IAAI,CAAlD,EAAqD;AACjD,YAAM,CAAC,GAAG,IAAI,CAAC,GAAL,CAAS,CAAC,CAAV,EAAa,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,KAAK,CAAC,CAAD,CAAjB,CAAb,CAAV;AACA,MAAA,IAAI,CAAC,QAAL,CAAc,MAAd,EAAsB,CAAC,GAAG,CAAJ,GAAQ,CAAC,GAAG,MAAZ,GAAqB,CAAC,GAAG,MAA/C,EAAuD,IAAvD;AACH;AACJ;;AAEO,EAAA,oBAAoB,CACxB,QADwB,EAExB,OAFwB,EAGxB,OAHwB,EAGT;AAEf,QAAI,CAAC,QAAL,EAAe;AACX,aAAO,IAAP;AACH;;AAED,QAAI,OAAO,KAAK,OAAZ,IAAuB,OAAO,GAAG,OAArC,EAA8C;AAC1C,aAAO,QAAP;AACH;;AAED,UAAM,KAAK,GAAG,OAAO,GAAG,OAAxB;AACA,UAAM,SAAS,GAAG,IAAI,CAAC,KAAL,CAAW,QAAQ,CAAC,MAAT,GAAkB,KAA7B,CAAlB;AACA,UAAM,QAAQ,GAAG,IAAI,YAAJ,CAAiB,SAAjB,CAAjB;AACA,QAAI,SAAS,GAAG,CAAhB;AACA,QAAI,SAAS,GAAG,CAAhB;;AACA,WAAO,SAAS,GAAG,SAAnB,EAA8B;AAC1B,YAAM,aAAa,GAAG,IAAI,CAAC,KAAL,CAAW,CAAC,SAAS,GAAG,CAAb,IAAkB,KAA7B,CAAtB;AACA,UAAI,KAAK,GAAG,CAAZ;AACA,UAAI,KAAK,GAAG,CAAZ;;AACA,aAAO,SAAS,GAAG,aAAZ,IAA6B,SAAS,GAAG,QAAQ,CAAC,MAAzD,EAAiE;AAC7D,QAAA,KAAK,IAAI,QAAQ,CAAC,SAAS,EAAV,CAAjB;AACA,QAAA,KAAK;AACR;;AACD,MAAA,QAAQ,CAAC,SAAS,EAAV,CAAR,GAAwB,KAAK,GAAG,KAAhC;AACH;;AAED,WAAO,QAAP;AACH;;AAtEsB","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nexport class RiffPcmEncoder {\r\n\r\n    private privActualSampleRate: number;\r\n    private privDesiredSampleRate: number;\r\n\r\n    public constructor(actualSampleRate: number, desiredSampleRate: number) {\r\n        this.privActualSampleRate = actualSampleRate;\r\n        this.privDesiredSampleRate = desiredSampleRate;\r\n    }\r\n\r\n    public encode(actualAudioFrame: Float32Array): ArrayBuffer {\r\n\r\n        const audioFrame = this.downSampleAudioFrame(actualAudioFrame, this.privActualSampleRate, this.privDesiredSampleRate);\r\n\r\n        if (!audioFrame) {\r\n            return null;\r\n        }\r\n\r\n        const audioLength = audioFrame.length * 2;\r\n\r\n        const buffer = new ArrayBuffer(audioLength);\r\n        const view = new DataView(buffer);\r\n        this.floatTo16BitPCM(view, 0, audioFrame);\r\n\r\n        return buffer;\r\n    }\r\n\r\n    private setString(view: DataView, offset: number, str: string): void {\r\n        for (let i = 0; i < str.length; i++) {\r\n            view.setUint8(offset + i, str.charCodeAt(i));\r\n        }\r\n    }\r\n\r\n    private floatTo16BitPCM(view: DataView, offset: number, input: Float32Array): void {\r\n        for (let i = 0; i < input.length; i++ , offset += 2) {\r\n            const s = Math.max(-1, Math.min(1, input[i]));\r\n            view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);\r\n        }\r\n    }\r\n\r\n    private downSampleAudioFrame(\r\n        srcFrame: Float32Array,\r\n        srcRate: number,\r\n        dstRate: number): Float32Array {\r\n\r\n        if (!srcFrame) {\r\n            return null;\r\n        }\r\n\r\n        if (dstRate === srcRate || dstRate > srcRate) {\r\n            return srcFrame;\r\n        }\r\n\r\n        const ratio = srcRate / dstRate;\r\n        const dstLength = Math.round(srcFrame.length / ratio);\r\n        const dstFrame = new Float32Array(dstLength);\r\n        let srcOffset = 0;\r\n        let dstOffset = 0;\r\n        while (dstOffset < dstLength) {\r\n            const nextSrcOffset = Math.round((dstOffset + 1) * ratio);\r\n            let accum = 0;\r\n            let count = 0;\r\n            while (srcOffset < nextSrcOffset && srcOffset < srcFrame.length) {\r\n                accum += srcFrame[srcOffset++];\r\n                count++;\r\n            }\r\n            dstFrame[dstOffset++] = accum / count;\r\n        }\r\n\r\n        return dstFrame;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}