{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { AutoDetectSourceLanguagesOpenRangeOptionName } from \"../common.speech/Exports\";\nimport { Contracts } from \"./Contracts\";\nimport { PropertyCollection, PropertyId } from \"./Exports\";\nimport { LanguageIdMode } from \"./LanguageIdMode\";\nimport { LanguageIdPriority } from \"./LanguageIdPriority\";\n/**\n * Language auto detect configuration.\n * @class AutoDetectSourceLanguageConfig\n * Added in version 1.13.0.\n */\n\nexport class AutoDetectSourceLanguageConfig {\n  constructor() {\n    this.privProperties = new PropertyCollection();\n    this.privProperties.setProperty(PropertyId.SpeechServiceConnection_AtStartLanguageIdPriority, \"Latency\");\n    this.privLanguageIdMode = LanguageIdMode.AtStart;\n  }\n  /**\n   * @member AutoDetectSourceLanguageConfig.fromOpenRange\n   * @function\n   * @public\n   * Only [[SpeechSynthesizer]] supports source language auto detection from open range,\n   * for [[Recognizer]], please use AutoDetectSourceLanguageConfig with specific source languages.\n   * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig\n   * @summary Creates an instance of the AutoDetectSourceLanguageConfig with open range.\n   */\n\n\n  static fromOpenRange() {\n    const config = new AutoDetectSourceLanguageConfig();\n    config.properties.setProperty(PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, AutoDetectSourceLanguagesOpenRangeOptionName);\n    return config;\n  }\n  /**\n   * @member AutoDetectSourceLanguageConfig.fromLanguages\n   * @function\n   * @public\n   * @param {string[]} languages Comma-separated string of languages (eg. \"en-US,fr-FR\") to populate properties of config.\n   * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig\n   * @summary Creates an instance of the AutoDetectSourceLanguageConfig with given languages.\n   */\n\n\n  static fromLanguages(languages) {\n    Contracts.throwIfArrayEmptyOrWhitespace(languages, \"languages\");\n    const config = new AutoDetectSourceLanguageConfig();\n    config.properties.setProperty(PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, languages.join());\n    return config;\n  }\n  /**\n   * @member AutoDetectSourceLanguageConfig.fromSourceLanguageConfigs\n   * @function\n   * @public\n   * @param {SourceLanguageConfig[]} configs SourceLanguageConfigs to populate properties of config.\n   * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig\n   * @summary Creates an instance of the AutoDetectSourceLanguageConfig with given SourceLanguageConfigs.\n   */\n\n\n  static fromSourceLanguageConfigs(configs) {\n    if (configs.length < 1) {\n      throw new Error(\"Expected non-empty SourceLanguageConfig array.\");\n    }\n\n    const autoConfig = new AutoDetectSourceLanguageConfig();\n    const langs = [];\n    configs.forEach(config => {\n      langs.push(config.language);\n\n      if (config.endpointId !== undefined && config.endpointId !== \"\") {\n        const customProperty = config.language + PropertyId.SpeechServiceConnection_EndpointId.toString();\n        autoConfig.properties.setProperty(customProperty, config.endpointId);\n      }\n    });\n    autoConfig.properties.setProperty(PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, langs.join());\n    return autoConfig;\n  }\n  /**\n   * @member AutoDetectSourceLanguageConfig.prototype.properties\n   * @function\n   * @public\n   * @return {PropertyCollection} Properties of the config.\n   * @summary Gets an auto detected language config properties\n   */\n\n\n  get properties() {\n    return this.privProperties;\n  }\n  /**\n   * @member AutoDetectSourceLanguageConfig.prototype.mode\n   * @function\n   * @public\n   * @param {LanguageIdMode} mode LID mode desired.\n   * @summary Sets LID operation to desired mode\n   */\n\n\n  set mode(mode) {\n    if (mode === LanguageIdMode.Continuous) {\n      this.privProperties.setProperty(PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, \"2\");\n      this.privProperties.setProperty(PropertyId.SpeechServiceConnection_ContinuousLanguageIdPriority, \"Latency\");\n    } else {\n      this.privProperties.setProperty(PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, \"1\");\n      this.privProperties.setProperty(PropertyId.SpeechServiceConnection_ContinuousLanguageIdPriority, undefined);\n    }\n\n    this.privLanguageIdMode = mode;\n  }\n  /**\n   * @member AutoDetectSourceLanguageConfig.prototype.priority\n   * @function\n   * @public\n   * @param {LanguageIdPriority} priority LID priority desired.\n   * @summary Sets LID operation to desired priority\n   */\n\n\n  set priority(priority) {\n    if (priority === LanguageIdPriority.Accuracy) {\n      if (this.privLanguageIdMode !== LanguageIdMode.Continuous) {\n        // Accuracy not allowed for continuous mode\n        this.privProperties.setProperty(PropertyId.SpeechServiceConnection_AtStartLanguageIdPriority, \"Accuracy\");\n      }\n    } else {\n      this.privProperties.setProperty(PropertyId.SpeechServiceConnection_ContinuousLanguageIdPriority, \"Latency\");\n      this.privProperties.setProperty(PropertyId.SpeechServiceConnection_AtStartLanguageIdPriority, \"Latency\");\n    }\n  }\n\n}","map":{"version":3,"sources":["src/sdk/AutoDetectSourceLanguageConfig.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { AutoDetectSourceLanguagesOpenRangeOptionName } from \"../common.speech/Exports\";\r\nimport {Contracts} from \"./Contracts\";\r\nimport {\r\n    PropertyCollection,\r\n    PropertyId,\r\n    SourceLanguageConfig,\r\n} from \"./Exports\";\r\nimport { LanguageIdMode } from \"./LanguageIdMode\";\r\nimport { LanguageIdPriority } from \"./LanguageIdPriority\";\r\n\r\n/**\r\n * Language auto detect configuration.\r\n * @class AutoDetectSourceLanguageConfig\r\n * Added in version 1.13.0.\r\n */\r\nexport class AutoDetectSourceLanguageConfig {\r\n    private privProperties: PropertyCollection;\r\n    private privLanguageIdMode: LanguageIdMode;\r\n\r\n    private constructor() {\r\n        this.privProperties = new PropertyCollection();\r\n        this.privProperties.setProperty(PropertyId.SpeechServiceConnection_AtStartLanguageIdPriority, \"Latency\");\r\n        this.privLanguageIdMode = LanguageIdMode.AtStart;\r\n    }\r\n\r\n    /**\r\n     * @member AutoDetectSourceLanguageConfig.fromOpenRange\r\n     * @function\r\n     * @public\r\n     * Only [[SpeechSynthesizer]] supports source language auto detection from open range,\r\n     * for [[Recognizer]], please use AutoDetectSourceLanguageConfig with specific source languages.\r\n     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig\r\n     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with open range.\r\n     */\r\n    public static fromOpenRange(): AutoDetectSourceLanguageConfig {\r\n        const config = new AutoDetectSourceLanguageConfig();\r\n        config.properties.setProperty(PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, AutoDetectSourceLanguagesOpenRangeOptionName);\r\n        return config;\r\n    }\r\n\r\n    /**\r\n     * @member AutoDetectSourceLanguageConfig.fromLanguages\r\n     * @function\r\n     * @public\r\n     * @param {string[]} languages Comma-separated string of languages (eg. \"en-US,fr-FR\") to populate properties of config.\r\n     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig\r\n     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with given languages.\r\n     */\r\n    public static fromLanguages(languages: string[]): AutoDetectSourceLanguageConfig {\r\n        Contracts.throwIfArrayEmptyOrWhitespace(languages, \"languages\");\r\n        const config = new AutoDetectSourceLanguageConfig();\r\n        config.properties.setProperty(PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, languages.join());\r\n        return config;\r\n    }\r\n\r\n    /**\r\n     * @member AutoDetectSourceLanguageConfig.fromSourceLanguageConfigs\r\n     * @function\r\n     * @public\r\n     * @param {SourceLanguageConfig[]} configs SourceLanguageConfigs to populate properties of config.\r\n     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig\r\n     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with given SourceLanguageConfigs.\r\n     */\r\n    public static fromSourceLanguageConfigs(configs: SourceLanguageConfig[]): AutoDetectSourceLanguageConfig {\r\n        if (configs.length < 1) {\r\n            throw new Error(\"Expected non-empty SourceLanguageConfig array.\");\r\n        }\r\n        const autoConfig = new AutoDetectSourceLanguageConfig();\r\n        const langs: string[] = [];\r\n        configs.forEach((config: SourceLanguageConfig): void => {\r\n            langs.push(config.language);\r\n            if (config.endpointId !== undefined && config.endpointId !== \"\") {\r\n                const customProperty = config.language + PropertyId.SpeechServiceConnection_EndpointId.toString();\r\n                autoConfig.properties.setProperty(customProperty, config.endpointId);\r\n            }\r\n        });\r\n        autoConfig.properties.setProperty(PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, langs.join());\r\n\r\n        return autoConfig;\r\n    }\r\n\r\n    /**\r\n     * @member AutoDetectSourceLanguageConfig.prototype.properties\r\n     * @function\r\n     * @public\r\n     * @return {PropertyCollection} Properties of the config.\r\n     * @summary Gets an auto detected language config properties\r\n     */\r\n    public get properties(): PropertyCollection {\r\n        return this.privProperties;\r\n    }\r\n\r\n    /**\r\n     * @member AutoDetectSourceLanguageConfig.prototype.mode\r\n     * @function\r\n     * @public\r\n     * @param {LanguageIdMode} mode LID mode desired.\r\n     * @summary Sets LID operation to desired mode\r\n     */\r\n    public set mode(mode: LanguageIdMode) {\r\n        if (mode === LanguageIdMode.Continuous) {\r\n            this.privProperties.setProperty(PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, \"2\");\r\n            this.privProperties.setProperty(PropertyId.SpeechServiceConnection_ContinuousLanguageIdPriority, \"Latency\");\r\n        } else {\r\n            this.privProperties.setProperty(PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, \"1\");\r\n            this.privProperties.setProperty(PropertyId.SpeechServiceConnection_ContinuousLanguageIdPriority, undefined);\r\n        }\r\n        this.privLanguageIdMode = mode;\r\n    }\r\n\r\n    /**\r\n     * @member AutoDetectSourceLanguageConfig.prototype.priority\r\n     * @function\r\n     * @public\r\n     * @param {LanguageIdPriority} priority LID priority desired.\r\n     * @summary Sets LID operation to desired priority\r\n     */\r\n    public set priority(priority: LanguageIdPriority) {\r\n        if (priority === LanguageIdPriority.Accuracy) {\r\n            if (this.privLanguageIdMode !== LanguageIdMode.Continuous) {\r\n                // Accuracy not allowed for continuous mode\r\n                this.privProperties.setProperty(PropertyId.SpeechServiceConnection_AtStartLanguageIdPriority, \"Accuracy\");\r\n            }\r\n        } else {\r\n            this.privProperties.setProperty(PropertyId.SpeechServiceConnection_ContinuousLanguageIdPriority, \"Latency\");\r\n            this.privProperties.setProperty(PropertyId.SpeechServiceConnection_AtStartLanguageIdPriority, \"Latency\");\r\n        }\r\n    }\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}